@Override public void onRequestPermissionsResult(int requestCode,@NonNull String permissions[],@NonNull int[] grantResults){	  if (requestCode == PERMISSION_CODE) {	    if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {	      launchPicker();	    }	  }	}
public static int limit(int number,int between,int and){	  if (number <= between) {	    return between;	  }	  if (number >= and) {	    return and;	  }	  return number;	}
public static float limit(float number,float between,float and){	  if (number <= between) {	    return between;	  }	  if (number >= and) {	    return and;	  }	  return number;	}
static public int floor(float value){	  return (int)(value + BIG_ENOUGH_FLOOR) - BIG_ENOUGH_INT;	}
static public int ceil(float value){	  return (int)(value + BIG_ENOUGH_CEIL) - BIG_ENOUGH_INT;	}
public static int[] deleteDuplicatedPages(int[] pages){	  List<Integer> result=new ArrayList<>();	  int lastInt=-1;	  for (  Integer currentInt : pages) {	    if (lastInt != currentInt) {	      result.add(currentInt);	    }	    lastInt=currentInt;	  }	  int[] arrayResult=new int[result.size()];	  for (int i=0; i < result.size(); i++) {	    arrayResult[i]=result.get(i);	  }	  return arrayResult;	}
public static int[] calculateIndexesInDuplicateArray(int[] originalUserPages){	  int[] result=new int[originalUserPages.length];	  if (originalUserPages.length == 0) {	    return result;	  }	  int index=0;	  result[0]=index;	  for (int i=1; i < originalUserPages.length; i++) {	    if (originalUserPages[i] != originalUserPages[i - 1]) {	      index++;	    }	    result[i]=index;	  }	  return result;	}
public boolean containsThumbnail(int page,RectF pageRelativeBounds){	  PagePart fakePart=new PagePart(page,null,pageRelativeBounds,true,0);	synchronized (thumbnails) {	    for (    PagePart part : thumbnails) {	      if (part.equals(fakePart)) {	        return true;	      }	    }	    return false;	  }	}
private void addWithoutDuplicates(Collection<PagePart> collection,PagePart newPart){	  for (  PagePart part : collection) {	    if (part.equals(newPart)) {	      newPart.getRenderedBitmap().recycle();	      return;	    }	  }	  collection.add(newPart);	}
private int loadWholePage(int page,GridSize grid,int nbOfPartsLoadable){	  calculatePartSize(grid);	  return loadPage(page,0,grid.rows - 1,0,grid.cols - 1,nbOfPartsLoadable);	}
private int loadPageCenter(Holder firstHolder,Holder lastHolder,GridSize grid,int nbOfPartsLoadable){	  calculatePartSize(grid);	  return loadPage(firstHolder.page,firstHolder.row,lastHolder.row,firstHolder.col,lastHolder.col,nbOfPartsLoadable);	}
private int loadPageEnd(Holder holder,GridSize grid,int nbOfPartsLoadable){	  calculatePartSize(grid);	  if (pdfView.isSwipeVertical()) {	    int firstRow=holder.row;	    return loadPage(holder.page,firstRow,grid.rows - 1,0,grid.cols - 1,nbOfPartsLoadable);	  }	 else {	    int firstCol=holder.col;	    return loadPage(holder.page,0,grid.rows - 1,firstCol,grid.cols - 1,nbOfPartsLoadable);	  }	}
private int loadPageStart(Holder holder,GridSize grid,int nbOfPartsLoadable){	  calculatePartSize(grid);	  if (pdfView.isSwipeVertical()) {	    int lastRow=holder.row;	    return loadPage(holder.page,0,lastRow,0,grid.cols - 1,nbOfPartsLoadable);	  }	 else {	    int lastCol=holder.col;	    return loadPage(holder.page,0,grid.rows - 1,0,lastCol,nbOfPartsLoadable);	  }	}
public void recalculatePageSizes(Size viewSize){	  pageSizes.clear();	  PageSizeCalculator calculator=new PageSizeCalculator(pageFitPolicy,originalMaxWidthPageSize,originalMaxHeightPageSize,viewSize);	  maxWidthPageSize=calculator.getOptimalMaxWidthPageSize();	  maxHeightPageSize=calculator.getOptimalMaxHeightPageSize();	  for (  Size size : originalPageSizes) {	    pageSizes.add(calculator.calculate(size));	  }	  if (autoSpacing) {	    prepareAutoSpacing(viewSize);	  }	  prepareDocLen();	  preparePagesOffset();	}
public SizeF getMaxPageSize(){	  return isVertical ? maxWidthPageSize : maxHeightPageSize;	}
public float getPageLength(int pageIndex,float zoom){	  SizeF size=getPageSize(pageIndex);	  return (isVertical ? size.getHeight() : size.getWidth()) * zoom;	}
public float getPageOffset(int pageIndex,float zoom){	  int docPage=documentPage(pageIndex);	  if (docPage < 0) {	    return 0;	  }	  return pageOffsets.get(pageIndex) * zoom;	}
public float getSecondaryPageOffset(int pageIndex,float zoom){	  SizeF pageSize=getPageSize(pageIndex);	  if (isVertical) {	    float maxWidth=getMaxPageWidth();	    return zoom * (maxWidth - pageSize.getWidth()) / 2;	  }	 else {	    float maxHeight=getMaxPageHeight();	    return zoom * (maxHeight - pageSize.getHeight()) / 2;	  }	}
public int determineValidPageNumberFrom(int userPage){	  if (userPage <= 0) {	    return 0;	  }	  if (originalUserPages != null) {	    if (userPage >= originalUserPages.length) {	      return originalUserPages.length - 1;	    }	  }	 else {	    if (userPage >= getPagesCount()) {	      return getPagesCount() - 1;	    }	  }	  return userPage;	}
public PDFView(Context context,AttributeSet set){	  super(context,set);	  renderingHandlerThread=new HandlerThread("PDF renderer");	  if (isInEditMode()) {	    return;	  }	  cacheManager=new CacheManager();	  animationManager=new AnimationManager(this);	  dragPinchManager=new DragPinchManager(this,animationManager);	  pagesLoader=new PagesLoader(this);	  paint=new Paint();	  debugPaint=new Paint();	  debugPaint.setStyle(Style.STROKE);	  pdfiumCore=new PdfiumCore(context);	  setWillNotDraw(false);	}
public void jumpTo(int page,boolean withAnimation){	  if (pdfFile == null) {	    return;	  }	  page=pdfFile.determineValidPageNumberFrom(page);	  float offset=page == 0 ? 0 : -pdfFile.getPageOffset(page,zoom);	  if (swipeVertical) {	    if (withAnimation) {	      animationManager.startYAnimation(currentYOffset,offset);	    }	 else {	      moveTo(currentXOffset,offset);	    }	  }	 else {	    if (withAnimation) {	      animationManager.startXAnimation(currentXOffset,offset);	    }	 else {	      moveTo(offset,currentYOffset);	    }	  }	  showPage(page);	}
public float getPositionOffset(){	  float offset;	  if (swipeVertical) {	    offset=-currentYOffset / (pdfFile.getDocLen(zoom) - getHeight());	  }	 else {	    offset=-currentXOffset / (pdfFile.getDocLen(zoom) - getWidth());	  }	  return MathUtils.limit(offset,0,1);	}
public void setPositionOffset(float progress,boolean moveHandle){	  if (swipeVertical) {	    moveTo(currentXOffset,(-pdfFile.getDocLen(zoom) + getHeight()) * progress,moveHandle);	  }	 else {	    moveTo((-pdfFile.getDocLen(zoom) + getWidth()) * progress,currentYOffset,moveHandle);	  }	  loadPageByOffset();	}
@Override public void computeScroll(){	  super.computeScroll();	  if (isInEditMode()) {	    return;	  }	  animationManager.computeFling();	}
private void drawPart(Canvas canvas,PagePart part){	  RectF pageRelativeBounds=part.getPageRelativeBounds();	  Bitmap renderedBitmap=part.getRenderedBitmap();	  if (renderedBitmap.isRecycled()) {	    return;	  }	  float localTranslationX=0;	  float localTranslationY=0;	  SizeF size=pdfFile.getPageSize(part.getPage());	  if (swipeVertical) {	    localTranslationY=pdfFile.getPageOffset(part.getPage(),zoom);	    float maxWidth=pdfFile.getMaxPageWidth();	    localTranslationX=toCurrentScale(maxWidth - size.getWidth()) / 2;	  }	 else {	    localTranslationX=pdfFile.getPageOffset(part.getPage(),zoom);	    float maxHeight=pdfFile.getMaxPageHeight();	    localTranslationY=toCurrentScale(maxHeight - size.getHeight()) / 2;	  }	  canvas.translate(localTranslationX,localTranslationY);	  Rect srcRect=new Rect(0,0,renderedBitmap.getWidth(),renderedBitmap.getHeight());	  float offsetX=toCurrentScale(pageRelativeBounds.left * size.getWidth());	  float offsetY=toCurrentScale(pageRelativeBounds.top * size.getHeight());	  float width=toCurrentScale(pageRelativeBounds.width() * size.getWidth());	  float height=toCurrentScale(pageRelativeBounds.height() * size.getHeight());	  RectF dstRect=new RectF((int)offsetX,(int)offsetY,(int)(offsetX + width),(int)(offsetY + height));	  float translationX=currentXOffset + localTranslationX;	  float translationY=currentYOffset + localTranslationY;	  if (translationX + dstRect.left >= getWidth() || translationX + dstRect.right <= 0 || translationY + dstRect.top >= getHeight() || translationY + dstRect.bottom <= 0) {	    canvas.translate(-localTranslationX,-localTranslationY);	    return;	  }	  canvas.drawBitmap(renderedBitmap,srcRect,dstRect,paint);	  if (Constants.DEBUG_MODE) {	    debugPaint.setColor(part.getPage() % 2 == 0 ? Color.RED : Color.BLUE);	    canvas.drawRect(dstRect,debugPaint);	  }	  canvas.translate(-localTranslationX,-localTranslationY);	}
public void loadPages(){	  if (pdfFile == null || renderingHandler == null) {	    return;	  }	  renderingHandler.removeMessages(RenderingHandler.MSG_RENDER_TASK);	  cacheManager.makeANewSet();	  pagesLoader.loadPages();	  redraw();	}
void loadComplete(PdfFile pdfFile){	  state=State.LOADED;	  this.pdfFile=pdfFile;	  if (!renderingHandlerThread.isAlive()) {	    renderingHandlerThread.start();	  }	  renderingHandler=new RenderingHandler(renderingHandlerThread.getLooper(),this);	  renderingHandler.start();	  if (scrollHandle != null) {	    scrollHandle.setupLayout(this);	    isScrollHandleInit=true;	  }	  dragPinchManager.enable();	  callbacks.callOnLoadComplete(pdfFile.getPagesCount());	  jumpTo(defaultPage,false);	}
public void onBitmapRendered(PagePart part){	  if (state == State.LOADED) {	    state=State.SHOWN;	    callbacks.callOnRender(pdfFile.getPagesCount());	  }	  if (part.isThumbnail()) {	    cacheManager.cacheThumbnail(part);	  }	 else {	    cacheManager.cachePart(part);	  }	  redraw();	}
public void moveTo(float offsetX,float offsetY,boolean moveHandle){	  if (swipeVertical) {	    float scaledPageWidth=toCurrentScale(pdfFile.getMaxPageWidth());	    if (scaledPageWidth < getWidth()) {	      offsetX=getWidth() / 2 - scaledPageWidth / 2;	    }	 else {	      if (offsetX > 0) {	        offsetX=0;	      }	 else       if (offsetX + scaledPageWidth < getWidth()) {	        offsetX=getWidth() - scaledPageWidth;	      }	    }	    float contentHeight=pdfFile.getDocLen(zoom);	    if (contentHeight < getHeight()) {	      offsetY=(getHeight() - contentHeight) / 2;	    }	 else {	      if (offsetY > 0) {	        offsetY=0;	      }	 else       if (offsetY + contentHeight < getHeight()) {	        offsetY=-contentHeight + getHeight();	      }	    }	    if (offsetY < currentYOffset) {	      scrollDir=ScrollDir.END;	    }	 else     if (offsetY > currentYOffset) {	      scrollDir=ScrollDir.START;	    }	 else {	      scrollDir=ScrollDir.NONE;	    }	  }	 else {	    float scaledPageHeight=toCurrentScale(pdfFile.getMaxPageHeight());	    if (scaledPageHeight < getHeight()) {	      offsetY=getHeight() / 2 - scaledPageHeight / 2;	    }	 else {	      if (offsetY > 0) {	        offsetY=0;	      }	 else       if (offsetY + scaledPageHeight < getHeight()) {	        offsetY=getHeight() - scaledPageHeight;	      }	    }	    float contentWidth=pdfFile.getDocLen(zoom);	    if (contentWidth < getWidth()) {	      offsetX=(getWidth() - contentWidth) / 2;	    }	 else {	      if (offsetX > 0) {	        offsetX=0;	      }	 else       if (offsetX + contentWidth < getWidth()) {	        offsetX=-contentWidth + getWidth();	      }	    }	    if (offsetX < currentXOffset) {	      scrollDir=ScrollDir.END;	    }	 else     if (offsetX > currentXOffset) {	      scrollDir=ScrollDir.START;	    }	 else {	      scrollDir=ScrollDir.NONE;	    }	  }	  currentXOffset=offsetX;	  currentYOffset=offsetY;	  float positionOffset=getPositionOffset();	  if (moveHandle && scrollHandle != null && !documentFitsView()) {	    scrollHandle.setScroll(positionOffset);	  }	  callbacks.callOnPageScroll(getCurrentPage(),positionOffset);	  redraw();	}
public void performPageSnap(){	  if (!pageSnap || pdfFile == null || pdfFile.getPagesCount() == 0) {	    return;	  }	  int centerPage=findFocusPage(currentXOffset,currentYOffset);	  SnapEdge edge=findSnapEdge(centerPage);	  if (edge == SnapEdge.NONE) {	    return;	  }	  float offset=snapOffsetForPage(centerPage,edge);	  if (swipeVertical) {	    animationManager.startYAnimation(currentYOffset,-offset);	  }	 else {	    animationManager.startXAnimation(currentXOffset,-offset);	  }	}
SnapEdge findSnapEdge(int page){	  if (!pageSnap || page < 0) {	    return SnapEdge.NONE;	  }	  float currentOffset=swipeVertical ? currentYOffset : currentXOffset;	  float offset=-pdfFile.getPageOffset(page,zoom);	  int length=swipeVertical ? getHeight() : getWidth();	  float pageLength=pdfFile.getPageLength(page,zoom);	  if (length >= pageLength) {	    return SnapEdge.CENTER;	  }	 else   if (currentOffset >= offset) {	    return SnapEdge.START;	  }	 else   if (offset - pageLength > currentOffset - length) {	    return SnapEdge.END;	  }	 else {	    return SnapEdge.NONE;	  }	}
float snapOffsetForPage(int pageIndex,SnapEdge edge){	  float offset=pdfFile.getPageOffset(pageIndex,zoom);	  float length=swipeVertical ? getHeight() : getWidth();	  float pageLength=pdfFile.getPageLength(pageIndex,zoom);	  if (edge == SnapEdge.CENTER) {	    offset=offset - length / 2f + pageLength / 2f;	  }	 else   if (edge == SnapEdge.END) {	    offset=offset - length + pageLength;	  }	  return offset;	}
public boolean pageFillsScreen(){	  float start=-pdfFile.getPageOffset(currentPage,zoom);	  float end=start - pdfFile.getPageLength(currentPage,zoom);	  if (isSwipeVertical()) {	    return start > currentYOffset && end < currentYOffset - getHeight();	  }	 else {	    return start > currentXOffset && end < currentXOffset - getWidth();	  }	}
public void moveRelativeTo(float dx,float dy){	  moveTo(currentXOffset + dx,currentYOffset + dy);	}
public void zoomTo(float zoom){	  this.zoom=zoom;	}
public void zoomCenteredTo(float zoom,PointF pivot){	  float dzoom=zoom / this.zoom;	  zoomTo(zoom);	  float baseX=currentXOffset * dzoom;	  float baseY=currentYOffset * dzoom;	  baseX+=(pivot.x - pivot.x * dzoom);	  baseY+=(pivot.y - pivot.y * dzoom);	  moveTo(baseX,baseY);	}
public void zoomCenteredRelativeTo(float dzoom,PointF pivot){	  zoomCenteredTo(zoom * dzoom,pivot);	}
public boolean documentFitsView(){	  float len=pdfFile.getDocLen(1);	  if (swipeVertical) {	    return len < getHeight();	  }	 else {	    return len < getWidth();	  }	}
public int getPageAtPositionOffset(float positionOffset){	  return pdfFile.getPageAtOffset(pdfFile.getDocLen(zoom) * positionOffset,zoom);	}
public PdfDocument.Meta getDocumentMeta(){	  if (pdfFile == null) {	    return null;	  }	  return pdfFile.getMetaData();	}
public List<PdfDocument.Bookmark> getTableOfContents(){	  if (pdfFile == null) {	    return Collections.emptyList();	  }	  return pdfFile.getBookmarks();	}
public List<PdfDocument.Link> getLinks(int page){	  if (pdfFile == null) {	    return Collections.emptyList();	  }	  return pdfFile.getPageLinks(page);	}
public Configurator fromAsset(String assetName){	  return new Configurator(new AssetSource(assetName));	}
public Configurator fromFile(File file){	  return new Configurator(new FileSource(file));	}
public Configurator fromUri(Uri uri){	  return new Configurator(new UriSource(uri));	}
public Configurator fromBytes(byte[] bytes){	  return new Configurator(new ByteArraySource(bytes));	}
public Configurator fromStream(InputStream stream){	  return new Configurator(new InputStreamSource(stream));	}
public Configurator fromSource(DocumentSource docSource){	  return new Configurator(docSource);	}
boolean onTap(MotionEvent e);
void onLongPress(MotionEvent e);
void onError(Throwable t);
void onPageError(int page,Throwable t);
void onPageChanged(int page,int pageCount);
void onPageScrolled(int page,float positionOffset);
void onInitiallyRendered(int nbPages);
void loadComplete(int nbPages);
void onLayerDrawn(Canvas canvas,float pageWidth,float pageHeight,int displayedPage);
void setScroll(float position);
void setupLayout(PDFView pdfView);
void destroyLayout();
void setPageNum(int pageNum);
boolean shown();
void show();
void hide();
void hideDelayed();
public void setTextSize(int size){	  textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP,size);	}
void handleLinkEvent(LinkTapEvent event);
public void enableCharacteristicNotify(BleNotifyCallback bleNotifyCallback,String uuid_notify){	  if (mCharacteristic != null && (mCharacteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    handleCharacteristicNotifyCallback(bleNotifyCallback,uuid_notify);	    setCharacteristicNotification(mBluetoothGatt,mCharacteristic,true,bleNotifyCallback);	  }	 else {	    if (bleNotifyCallback != null)     bleNotifyCallback.onNotifyFailure(new OtherException("this characteristic not support notify!"));	  }	}
public boolean disableCharacteristicNotify(){	  if (mCharacteristic != null && (mCharacteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    return setCharacteristicNotification(mBluetoothGatt,mCharacteristic,false,null);	  }	 else {	    return false;	  }	}
private boolean setCharacteristicNotification(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,boolean enable,BleNotifyCallback bleNotifyCallback){	  if (gatt == null || characteristic == null) {	    notifyMsgInit();	    if (bleNotifyCallback != null)     bleNotifyCallback.onNotifyFailure(new OtherException("gatt or characteristic equal null"));	    return false;	  }	  boolean success1=gatt.setCharacteristicNotification(characteristic,enable);	  if (!success1) {	    notifyMsgInit();	    if (bleNotifyCallback != null)     bleNotifyCallback.onNotifyFailure(new OtherException("gatt setCharacteristicNotification fail"));	    return false;	  }	  BluetoothGattDescriptor descriptor=characteristic.getDescriptor(formUUID(UUID_CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR));	  if (descriptor == null) {	    notifyMsgInit();	    if (bleNotifyCallback != null)     bleNotifyCallback.onNotifyFailure(new OtherException("descriptor equals null"));	    return false;	  }	 else {	    descriptor.setValue(enable ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);	    boolean success2=gatt.writeDescriptor(descriptor);	    if (!success2) {	      notifyMsgInit();	      if (bleNotifyCallback != null)       bleNotifyCallback.onNotifyFailure(new OtherException("gatt writeDescriptor fail"));	    }	    return success2;	  }	}
public void enableCharacteristicIndicate(BleIndicateCallback bleIndicateCallback,String uuid_indicate){	  if (mCharacteristic != null && (mCharacteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    handleCharacteristicIndicateCallback(bleIndicateCallback,uuid_indicate);	    setCharacteristicIndication(mBluetoothGatt,mCharacteristic,true,bleIndicateCallback);	  }	 else {	    if (bleIndicateCallback != null)     bleIndicateCallback.onIndicateFailure(new OtherException("this characteristic not support indicate!"));	  }	}
public boolean disableCharacteristicIndicate(){	  if (mCharacteristic != null && (mCharacteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    return setCharacteristicIndication(mBluetoothGatt,mCharacteristic,false,null);	  }	 else {	    return false;	  }	}
private boolean setCharacteristicIndication(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,boolean enable,BleIndicateCallback bleIndicateCallback){	  if (gatt == null || characteristic == null) {	    indicateMsgInit();	    if (bleIndicateCallback != null)     bleIndicateCallback.onIndicateFailure(new OtherException("gatt or characteristic equal null"));	    return false;	  }	  boolean success1=gatt.setCharacteristicNotification(characteristic,enable);	  if (!success1) {	    indicateMsgInit();	    if (bleIndicateCallback != null)     bleIndicateCallback.onIndicateFailure(new OtherException("gatt setCharacteristicNotification fail"));	    return false;	  }	  BluetoothGattDescriptor descriptor=characteristic.getDescriptor(formUUID(UUID_CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR));	  if (descriptor == null) {	    indicateMsgInit();	    if (bleIndicateCallback != null)     bleIndicateCallback.onIndicateFailure(new OtherException("descriptor equals null"));	    return false;	  }	 else {	    descriptor.setValue(enable ? BluetoothGattDescriptor.ENABLE_INDICATION_VALUE : BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);	    boolean success2=gatt.writeDescriptor(descriptor);	    if (!success2) {	      indicateMsgInit();	      if (bleIndicateCallback != null)       bleIndicateCallback.onIndicateFailure(new OtherException("gatt writeDescriptor fail"));	    }	    return success2;	  }	}
public void writeCharacteristic(byte[] data,BleWriteCallback bleWriteCallback,String uuid_write){	  if (data == null || data.length <= 0) {	    if (bleWriteCallback != null)     bleWriteCallback.onWriteFailure(new OtherException("the data to be written is empty"));	    return;	  }	  if (mCharacteristic == null || (mCharacteristic.getProperties() & (BluetoothGattCharacteristic.PROPERTY_WRITE | BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE)) == 0) {	    if (bleWriteCallback != null)     bleWriteCallback.onWriteFailure(new OtherException("this characteristic not support write!"));	    return;	  }	  if (mCharacteristic.setValue(data)) {	    handleCharacteristicWriteCallback(bleWriteCallback,uuid_write);	    if (!mBluetoothGatt.writeCharacteristic(mCharacteristic)) {	      writeMsgInit();	      if (bleWriteCallback != null)       bleWriteCallback.onWriteFailure(new OtherException("gatt writeCharacteristic fail"));	    }	  }	 else {	    if (bleWriteCallback != null)     bleWriteCallback.onWriteFailure(new OtherException("Updates the locally stored value of this characteristic fail"));	  }	}
public void readCharacteristic(BleReadCallback bleReadCallback,String uuid_read){	  if (mCharacteristic != null && (mCharacteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) > 0) {	    handleCharacteristicReadCallback(bleReadCallback,uuid_read);	    if (!mBluetoothGatt.readCharacteristic(mCharacteristic)) {	      readMsgInit();	      if (bleReadCallback != null)       bleReadCallback.onReadFailure(new OtherException("gatt readCharacteristic fail"));	    }	  }	 else {	    if (bleReadCallback != null)     bleReadCallback.onReadFailure(new OtherException("this characteristic not support read!"));	  }	}
public void readRemoteRssi(BleRssiCallback bleRssiCallback){	  handleRSSIReadCallback(bleRssiCallback);	  if (!mBluetoothGatt.readRemoteRssi()) {	    rssiMsgInit();	    if (bleRssiCallback != null)     bleRssiCallback.onRssiFailure(new OtherException("gatt readRemoteRssi fail"));	  }	}
public void setMtu(int requiredMtu,BleMtuChangedCallback bleMtuChangedCallback){	  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {	    handleSetMtuCallback(bleMtuChangedCallback);	    if (!mBluetoothGatt.requestMtu(requiredMtu)) {	      mtuChangedMsgInit();	      if (bleMtuChangedCallback != null)       bleMtuChangedCallback.onSetMTUFailure(new OtherException("gatt requestMtu fail"));	    }	  }	 else {	    if (bleMtuChangedCallback != null)     bleMtuChangedCallback.onSetMTUFailure(new OtherException("API level lower than 21"));	  }	}
private void handleCharacteristicNotifyCallback(BleNotifyCallback bleNotifyCallback,String uuid_notify){	  if (bleNotifyCallback != null) {	    notifyMsgInit();	    bleNotifyCallback.setKey(uuid_notify);	    bleNotifyCallback.setHandler(mHandler);	    mBleBluetooth.addNotifyCallback(uuid_notify,bleNotifyCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_CHA_NOTIFY_START,bleNotifyCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleCharacteristicIndicateCallback(BleIndicateCallback bleIndicateCallback,String uuid_indicate){	  if (bleIndicateCallback != null) {	    indicateMsgInit();	    bleIndicateCallback.setKey(uuid_indicate);	    bleIndicateCallback.setHandler(mHandler);	    mBleBluetooth.addIndicateCallback(uuid_indicate,bleIndicateCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_CHA_INDICATE_START,bleIndicateCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleCharacteristicWriteCallback(BleWriteCallback bleWriteCallback,String uuid_write){	  if (bleWriteCallback != null) {	    writeMsgInit();	    bleWriteCallback.setKey(uuid_write);	    bleWriteCallback.setHandler(mHandler);	    mBleBluetooth.addWriteCallback(uuid_write,bleWriteCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_CHA_WRITE_START,bleWriteCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleCharacteristicReadCallback(BleReadCallback bleReadCallback,String uuid_read){	  if (bleReadCallback != null) {	    readMsgInit();	    bleReadCallback.setKey(uuid_read);	    bleReadCallback.setHandler(mHandler);	    mBleBluetooth.addReadCallback(uuid_read,bleReadCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_CHA_READ_START,bleReadCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleRSSIReadCallback(BleRssiCallback bleRssiCallback){	  if (bleRssiCallback != null) {	    rssiMsgInit();	    bleRssiCallback.setHandler(mHandler);	    mBleBluetooth.addRssiCallback(bleRssiCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_READ_RSSI_START,bleRssiCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleSetMtuCallback(BleMtuChangedCallback bleMtuChangedCallback){	  if (bleMtuChangedCallback != null) {	    mtuChangedMsgInit();	    bleMtuChangedCallback.setHandler(mHandler);	    mBleBluetooth.addMtuChangedCallback(bleMtuChangedCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_SET_MTU_START,bleMtuChangedCallback),BleManager.getInstance().getOperateTimeout());	  }	}
public Context getContext(){	  return context;	}
public BluetoothManager getBluetoothManager(){	  return bluetoothManager;	}
public BluetoothAdapter getBluetoothAdapter(){	  return bluetoothAdapter;	}
public BleScanRuleConfig getScanRuleConfig(){	  return bleScanRuleConfig;	}
public MultipleBluetoothController getMultipleBluetoothController(){	  return multipleBluetoothController;	}
public void initScanRule(BleScanRuleConfig config){	  this.bleScanRuleConfig=config;	}
public int getMaxConnectCount(){	  return maxConnectCount;	}
public BleManager setMaxConnectCount(int count){	  if (count > DEFAULT_MAX_MULTIPLE_DEVICE)   count=DEFAULT_MAX_MULTIPLE_DEVICE;	  this.maxConnectCount=count;	  return this;	}
public int getOperateTimeout(){	  return operateTimeout;	}
public BleManager setOperateTimeout(int count){	  this.operateTimeout=count;	  return this;	}
public int getReConnectCount(){	  return reConnectCount;	}
public long getReConnectInterval(){	  return reConnectInterval;	}
public BleManager setReConnectCount(int count){	  return setReConnectCount(count,DEFAULT_CONNECT_RETRY_INTERVAL);	}
public BleManager setReConnectCount(int count,long interval){	  if (count > 10)   count=10;	  if (interval < 0)   interval=0;	  this.reConnectCount=count;	  this.reConnectInterval=interval;	  return this;	}
public int getSplitWriteNum(){	  return splitWriteNum;	}
public BleManager setSplitWriteNum(int num){	  this.splitWriteNum=num;	  return this;	}
public long getConnectOverTime(){	  return connectOverTime;	}
public BleManager setConnectOverTime(long time){	  if (time <= 0) {	    time=100;	  }	  this.connectOverTime=time;	  return this;	}
public BleManager enableLog(boolean enable){	  BleLog.isPrint=enable;	  return this;	}
public void scan(BleScanCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleScanCallback can not be Null!");	  }	  if (!isBlueEnable()) {	    BleLog.e("Bluetooth not enable!");	    callback.onScanStarted(false);	    return;	  }	  UUID[] serviceUuids=bleScanRuleConfig.getServiceUuids();	  String[] deviceNames=bleScanRuleConfig.getDeviceNames();	  String deviceMac=bleScanRuleConfig.getDeviceMac();	  boolean fuzzy=bleScanRuleConfig.isFuzzy();	  long timeOut=bleScanRuleConfig.getScanTimeOut();	  BleScanner.getInstance().scan(serviceUuids,deviceNames,deviceMac,fuzzy,timeOut,callback);	}
public void scanAndConnect(BleScanAndConnectCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleScanAndConnectCallback can not be Null!");	  }	  if (!isBlueEnable()) {	    BleLog.e("Bluetooth not enable!");	    callback.onScanStarted(false);	    return;	  }	  UUID[] serviceUuids=bleScanRuleConfig.getServiceUuids();	  String[] deviceNames=bleScanRuleConfig.getDeviceNames();	  String deviceMac=bleScanRuleConfig.getDeviceMac();	  boolean fuzzy=bleScanRuleConfig.isFuzzy();	  long timeOut=bleScanRuleConfig.getScanTimeOut();	  BleScanner.getInstance().scanAndConnect(serviceUuids,deviceNames,deviceMac,fuzzy,timeOut,callback);	}
public BluetoothGatt connect(BleDevice bleDevice,BleGattCallback bleGattCallback){	  if (bleGattCallback == null) {	    throw new IllegalArgumentException("BleGattCallback can not be Null!");	  }	  if (!isBlueEnable()) {	    BleLog.e("Bluetooth not enable!");	    bleGattCallback.onConnectFail(bleDevice,new OtherException("Bluetooth not enable!"));	    return null;	  }	  if (Looper.myLooper() == null || Looper.myLooper() != Looper.getMainLooper()) {	    BleLog.w("Be careful: currentThread is not MainThread!");	  }	  if (bleDevice == null || bleDevice.getDevice() == null) {	    bleGattCallback.onConnectFail(bleDevice,new OtherException("Not Found Device Exception Occurred!"));	  }	 else {	    BleBluetooth bleBluetooth=multipleBluetoothController.buildConnectingBle(bleDevice);	    boolean autoConnect=bleScanRuleConfig.isAutoConnect();	    return bleBluetooth.connect(bleDevice,autoConnect,bleGattCallback);	  }	  return null;	}
public BluetoothGatt connect(String mac,BleGattCallback bleGattCallback){	  BluetoothDevice bluetoothDevice=getBluetoothAdapter().getRemoteDevice(mac);	  BleDevice bleDevice=new BleDevice(bluetoothDevice,0,null,0);	  return connect(bleDevice,bleGattCallback);	}
public void cancelScan(){	  BleScanner.getInstance().stopLeScan();	}
public void notify(BleDevice bleDevice,String uuid_service,String uuid_notify,BleNotifyCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleNotifyCallback can not be Null!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onNotifyFailure(new OtherException("This device not connect!"));	  }	 else {	    bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_notify).enableCharacteristicNotify(callback,uuid_notify);	  }	}
public void indicate(BleDevice bleDevice,String uuid_service,String uuid_indicate,BleIndicateCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleIndicateCallback can not be Null!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onIndicateFailure(new OtherException("This device not connect!"));	  }	 else {	    bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_indicate).enableCharacteristicIndicate(callback,uuid_indicate);	  }	}
public boolean stopNotify(BleDevice bleDevice,String uuid_service,String uuid_notify){	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    return false;	  }	  boolean success=bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_notify).disableCharacteristicNotify();	  if (success) {	    bleBluetooth.removeNotifyCallback(uuid_notify);	  }	  return success;	}
public boolean stopIndicate(BleDevice bleDevice,String uuid_service,String uuid_indicate){	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    return false;	  }	  boolean success=bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_indicate).disableCharacteristicIndicate();	  if (success) {	    bleBluetooth.removeIndicateCallback(uuid_indicate);	  }	  return success;	}
public void write(BleDevice bleDevice,String uuid_service,String uuid_write,byte[] data,BleWriteCallback callback){	  write(bleDevice,uuid_service,uuid_write,data,true,callback);	}
public void write(BleDevice bleDevice,String uuid_service,String uuid_write,byte[] data,boolean split,BleWriteCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleWriteCallback can not be Null!");	  }	  if (data == null) {	    BleLog.e("data is Null!");	    callback.onWriteFailure(new OtherException("data is Null!"));	    return;	  }	  if (data.length > 20 && !split) {	    BleLog.w("Be careful: data's length beyond 20! Ensure MTU higher than 23, or use spilt write!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onWriteFailure(new OtherException("This device not connect!"));	  }	 else {	    if (split && data.length > 20) {	      new SplitWriter().splitWrite(bleBluetooth,uuid_service,uuid_write,data,callback);	    }	 else {	      bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_write).writeCharacteristic(data,callback,uuid_write);	    }	  }	}
public void read(BleDevice bleDevice,String uuid_service,String uuid_read,BleReadCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleReadCallback can not be Null!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onReadFailure(new OtherException("This device is not connected!"));	  }	 else {	    bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_read).readCharacteristic(callback,uuid_read);	  }	}
public void readRssi(BleDevice bleDevice,BleRssiCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleRssiCallback can not be Null!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onRssiFailure(new OtherException("This device is not connected!"));	  }	 else {	    bleBluetooth.newBleConnector().readRemoteRssi(callback);	  }	}
public void setMtu(BleDevice bleDevice,int mtu,BleMtuChangedCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleMtuChangedCallback can not be Null!");	  }	  if (mtu > DEFAULT_MAX_MTU) {	    BleLog.e("requiredMtu should lower than 512 !");	    callback.onSetMTUFailure(new OtherException("requiredMtu should lower than 512 !"));	    return;	  }	  if (mtu < DEFAULT_MTU) {	    BleLog.e("requiredMtu should higher than 23 !");	    callback.onSetMTUFailure(new OtherException("requiredMtu should higher than 23 !"));	    return;	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onSetMTUFailure(new OtherException("This device is not connected!"));	  }	 else {	    bleBluetooth.newBleConnector().setMtu(mtu,callback);	  }	}
public boolean isSupportBle(){	  return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2 && context.getApplicationContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);	}
public void enableBluetooth(){	  if (bluetoothAdapter != null) {	    bluetoothAdapter.enable();	  }	}
public void disableBluetooth(){	  if (bluetoothAdapter != null) {	    if (bluetoothAdapter.isEnabled())     bluetoothAdapter.disable();	  }	}
public boolean isBlueEnable(){	  return bluetoothAdapter != null && bluetoothAdapter.isEnabled();	}
public int getConnectState(BleDevice bleDevice){	  if (bleDevice != null) {	    return bluetoothManager.getConnectionState(bleDevice.getDevice(),BluetoothProfile.GATT);	  }	 else {	    return BluetoothProfile.STATE_DISCONNECTED;	  }	}
static ImmutableMap<String,PublicSuffixType> parseTrie(CharSequence encoded){	  ImmutableMap.Builder<String,PublicSuffixType> builder=ImmutableMap.builder();	  int encodedLen=encoded.length();	  int idx=0;	  while (idx < encodedLen) {	    idx+=doParseTrieToBuilder(Lists.<CharSequence>newLinkedList(),encoded,idx,builder);	  }	  return builder.build();	}
private static int doParseTrieToBuilder(List<CharSequence> stack,CharSequence encoded,int start,ImmutableMap.Builder<String,PublicSuffixType> builder){	  int encodedLen=encoded.length();	  int idx=start;	  char c='\0';	  for (; idx < encodedLen; idx++) {	    c=encoded.charAt(idx);	    if (c == '&' || c == '?' || c == '!' || c == ':' || c == ',') {	      break;	    }	  }	  stack.add(0,reverse(encoded.subSequence(start,idx)));	  if (c == '!' || c == '?' || c == ':' || c == ',') {	    String domain=PREFIX_JOINER.join(stack);	    if (domain.length() > 0) {	      builder.put(domain,PublicSuffixType.fromCode(c));	    }	  }	  idx++;	  if (c != '?' && c != ',') {	    while (idx < encodedLen) {	      idx+=doParseTrieToBuilder(stack,encoded,idx,builder);	      if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {	        idx++;	        break;	      }	    }	  }	  stack.remove(0);	  return idx - start;	}
static ImmutableMap<String,PublicSuffixType> parseTrie(CharSequence encoded){	  ImmutableMap.Builder<String,PublicSuffixType> builder=ImmutableMap.builder();	  int encodedLen=encoded.length();	  int idx=0;	  while (idx < encodedLen) {	    idx+=doParseTrieToBuilder(Lists.<CharSequence>newLinkedList(),encoded,idx,builder);	  }	  return builder.build();	}
private static int doParseTrieToBuilder(List<CharSequence> stack,CharSequence encoded,int start,ImmutableMap.Builder<String,PublicSuffixType> builder){	  int encodedLen=encoded.length();	  int idx=start;	  char c='\0';	  for (; idx < encodedLen; idx++) {	    c=encoded.charAt(idx);	    if (c == '&' || c == '?' || c == '!' || c == ':' || c == ',') {	      break;	    }	  }	  stack.add(0,reverse(encoded.subSequence(start,idx)));	  if (c == '!' || c == '?' || c == ':' || c == ',') {	    String domain=PREFIX_JOINER.join(stack);	    if (domain.length() > 0) {	      builder.put(domain,PublicSuffixType.fromCode(c));	    }	  }	  idx++;	  if (c != '?' && c != ',') {	    while (idx < encodedLen) {	      idx+=doParseTrieToBuilder(stack,encoded,idx,builder);	      if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {	        idx++;	        break;	      }	    }	  }	  stack.remove(0);	  return idx - start;	}
@Beta public static BigInteger ceilingPowerOfTwo(BigInteger x){	  return BigInteger.ZERO.setBit(log2(x,RoundingMode.CEILING));	}
@Beta public static BigInteger floorPowerOfTwo(BigInteger x){	  return BigInteger.ZERO.setBit(log2(x,RoundingMode.FLOOR));	}
public static boolean isPowerOfTwo(BigInteger x){	  checkNotNull(x);	  return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1;	}
@SuppressWarnings("fallthrough") public static int log2(BigInteger x,RoundingMode mode){	  checkPositive("x",checkNotNull(x));	  int logFloor=x.bitLength() - 1;	switch (mode) {	case UNNECESSARY:	    checkRoundingUnnecessary(isPowerOfTwo(x));	case DOWN:	case FLOOR:	  return logFloor;	case UP:	case CEILING:	return isPowerOfTwo(x) ? logFloor : logFloor + 1;	case HALF_DOWN:	case HALF_UP:	case HALF_EVEN:	if (logFloor < SQRT2_PRECOMPUTE_THRESHOLD) {	BigInteger halfPower=SQRT2_PRECOMPUTED_BITS.shiftRight(SQRT2_PRECOMPUTE_THRESHOLD - logFloor);	if (x.compareTo(halfPower) <= 0) {	  return logFloor;	}	 else {	  return logFloor + 1;	}	}	BigInteger x2=x.pow(2);	int logX2Floor=x2.bitLength() - 1;	return (logX2Floor < 2 * logFloor + 1) ? logFloor : logFloor + 1;	default :	throw new AssertionError();	}	}
@GwtIncompatible @SuppressWarnings("fallthrough") public static int log10(BigInteger x,RoundingMode mode){	  checkPositive("x",x);	  if (fitsInLong(x)) {	    return LongMath.log10(x.longValue(),mode);	  }	  int approxLog10=(int)(log2(x,FLOOR) * LN_2 / LN_10);	  BigInteger approxPow=BigInteger.TEN.pow(approxLog10);	  int approxCmp=approxPow.compareTo(x);	  if (approxCmp > 0) {	    do {	      approxLog10--;	      approxPow=approxPow.divide(BigInteger.TEN);	      approxCmp=approxPow.compareTo(x);	    }	 while (approxCmp > 0);	  }	 else {	    BigInteger nextPow=BigInteger.TEN.multiply(approxPow);	    int nextCmp=nextPow.compareTo(x);	    while (nextCmp <= 0) {	      approxLog10++;	      approxPow=nextPow;	      approxCmp=nextCmp;	      nextPow=BigInteger.TEN.multiply(approxPow);	      nextCmp=nextPow.compareTo(x);	    }	  }	  int floorLog=approxLog10;	  BigInteger floorPow=approxPow;	  int floorCmp=approxCmp;	switch (mode) {	case UNNECESSARY:	    checkRoundingUnnecessary(floorCmp == 0);	case FLOOR:	case DOWN:	  return floorLog;	case CEILING:	case UP:	return floorPow.equals(x) ? floorLog : floorLog + 1;	case HALF_DOWN:	case HALF_UP:	case HALF_EVEN:	BigInteger x2=x.pow(2);	BigInteger halfPowerSquared=floorPow.pow(2).multiply(BigInteger.TEN);	return (x2.compareTo(halfPowerSquared) <= 0) ? floorLog : floorLog + 1;	default :	throw new AssertionError();	}	}
@GwtIncompatible @SuppressWarnings("fallthrough") public static BigInteger sqrt(BigInteger x,RoundingMode mode){	  checkNonNegative("x",x);	  if (fitsInLong(x)) {	    return BigInteger.valueOf(LongMath.sqrt(x.longValue(),mode));	  }	  BigInteger sqrtFloor=sqrtFloor(x);	switch (mode) {	case UNNECESSARY:	    checkRoundingUnnecessary(sqrtFloor.pow(2).equals(x));	case FLOOR:	case DOWN:	  return sqrtFloor;	case CEILING:	case UP:	int sqrtFloorInt=sqrtFloor.intValue();	boolean sqrtFloorIsExact=(sqrtFloorInt * sqrtFloorInt == x.intValue()) && sqrtFloor.pow(2).equals(x);	return sqrtFloorIsExact ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);	case HALF_DOWN:	case HALF_UP:	case HALF_EVEN:	BigInteger halfSquare=sqrtFloor.pow(2).add(sqrtFloor);	return (halfSquare.compareTo(x) >= 0) ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);	default :	throw new AssertionError();	}	}
@GwtIncompatible public static BigInteger divide(BigInteger p,BigInteger q,RoundingMode mode){	  BigDecimal pDec=new BigDecimal(p);	  BigDecimal qDec=new BigDecimal(q);	  return pDec.divide(qDec,0,mode).toBigIntegerExact();	}
public static BigInteger factorial(int n){	  checkNonNegative("n",n);	  if (n < LongMath.factorials.length) {	    return BigInteger.valueOf(LongMath.factorials[n]);	  }	  int approxSize=IntMath.divide(n * IntMath.log2(n,CEILING),Long.SIZE,CEILING);	  ArrayList<BigInteger> bignums=new ArrayList<>(approxSize);	  int startingNumber=LongMath.factorials.length;	  long product=LongMath.factorials[startingNumber - 1];	  int shift=Long.numberOfTrailingZeros(product);	  product>>=shift;	  int productBits=LongMath.log2(product,FLOOR) + 1;	  int bits=LongMath.log2(startingNumber,FLOOR) + 1;	  int nextPowerOfTwo=1 << (bits - 1);	  for (long num=startingNumber; num <= n; num++) {	    if ((num & nextPowerOfTwo) != 0) {	      nextPowerOfTwo<<=1;	      bits++;	    }	    int tz=Long.numberOfTrailingZeros(num);	    long normalizedNum=num >> tz;	    shift+=tz;	    int normalizedBits=bits - tz;	    if (normalizedBits + productBits >= Long.SIZE) {	      bignums.add(BigInteger.valueOf(product));	      product=1;	      productBits=0;	    }	    product*=normalizedNum;	    productBits=LongMath.log2(product,FLOOR) + 1;	  }	  if (product > 1) {	    bignums.add(BigInteger.valueOf(product));	  }	  return listProduct(bignums).shiftLeft(shift);	}
public static BigInteger binomial(int n,int k){	  checkNonNegative("n",n);	  checkNonNegative("k",k);	  checkArgument(k <= n,"k (%s) > n (%s)",k,n);	  if (k > (n >> 1)) {	    k=n - k;	  }	  if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {	    return BigInteger.valueOf(LongMath.binomial(n,k));	  }	  BigInteger accum=BigInteger.ONE;	  long numeratorAccum=n;	  long denominatorAccum=1;	  int bits=LongMath.log2(n,RoundingMode.CEILING);	  int numeratorBits=bits;	  for (int i=1; i < k; i++) {	    int p=n - i;	    int q=i + 1;	    if (numeratorBits + bits >= Long.SIZE - 1) {	      accum=accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));	      numeratorAccum=p;	      denominatorAccum=q;	      numeratorBits=bits;	    }	 else {	      numeratorAccum*=p;	      denominatorAccum*=q;	      numeratorBits+=bits;	    }	  }	  return accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));	}
PairedStats(Stats xStats,Stats yStats,double sumOfProductsOfDeltas){	  this.xStats=xStats;	  this.yStats=yStats;	  this.sumOfProductsOfDeltas=sumOfProductsOfDeltas;	}
public long count(){	  return xStats.count();	}
public Stats xStats(){	  return xStats;	}
public Stats yStats(){	  return yStats;	}
public double populationCovariance(){	  checkState(count() != 0);	  return sumOfProductsOfDeltas / count();	}