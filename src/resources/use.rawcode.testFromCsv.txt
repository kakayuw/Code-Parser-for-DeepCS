@OptionsItem(R.id.pickFile) void pickFile(){	  int permissionCheck=ContextCompat.checkSelfPermission(this,READ_EXTERNAL_STORAGE);	  if (permissionCheck != PackageManager.PERMISSION_GRANTED) {	    ActivityCompat.requestPermissions(this,new String[]{READ_EXTERNAL_STORAGE},PERMISSION_CODE);	    return;	  }	  launchPicker();	}
void launchPicker(){	  Intent intent=new Intent(Intent.ACTION_GET_CONTENT);	  intent.setType("application/pdf");	  try {	    startActivityForResult(intent,REQUEST_CODE);	  }	 catch (  ActivityNotFoundException e) {	    Toast.makeText(this,R.string.toast_pick_file_error,Toast.LENGTH_SHORT).show();	  }	}
@AfterViews void afterViews(){	  pdfView.setBackgroundColor(Color.LTGRAY);	  if (uri != null) {	    displayFromUri(uri);	  }	 else {	    displayFromAsset(SAMPLE_FILE);	  }	  setTitle(pdfFileName);	}
private void displayFromAsset(String assetFileName){	  pdfFileName=assetFileName;	  pdfView.fromAsset(SAMPLE_FILE).defaultPage(pageNumber).onPageChange(this).enableAnnotationRendering(true).onLoad(this).scrollHandle(new DefaultScrollHandle(this)).spacing(10).onPageError(this).pageFitPolicy(FitPolicy.BOTH).load();	}
private void displayFromUri(Uri uri){	  pdfFileName=getFileName(uri);	  pdfView.fromUri(uri).defaultPage(pageNumber).onPageChange(this).enableAnnotationRendering(true).onLoad(this).scrollHandle(new DefaultScrollHandle(this)).spacing(10).onPageError(this).load();	}
@OnActivityResult(REQUEST_CODE) public void onResult(int resultCode,Intent intent){	  if (resultCode == RESULT_OK) {	    uri=intent.getData();	    displayFromUri(uri);	  }	}
@Override public void onPageChanged(int page,int pageCount){	  pageNumber=page;	  setTitle(String.format("%s %s / %s",pdfFileName,page + 1,pageCount));	}
public String getFileName(Uri uri){	  String result=null;	  if (uri.getScheme().equals("content")) {	    Cursor cursor=getContentResolver().query(uri,null,null,null,null);	    try {	      if (cursor != null && cursor.moveToFirst()) {	        result=cursor.getString(cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME));	      }	    }	  finally {	      if (cursor != null) {	        cursor.close();	      }	    }	  }	  if (result == null) {	    result=uri.getLastPathSegment();	  }	  return result;	}
@Override public void loadComplete(int nbPages){	  PdfDocument.Meta meta=pdfView.getDocumentMeta();	  Log.e(TAG,"title = " + meta.getTitle());	  Log.e(TAG,"author = " + meta.getAuthor());	  Log.e(TAG,"subject = " + meta.getSubject());	  Log.e(TAG,"keywords = " + meta.getKeywords());	  Log.e(TAG,"creator = " + meta.getCreator());	  Log.e(TAG,"producer = " + meta.getProducer());	  Log.e(TAG,"creationDate = " + meta.getCreationDate());	  Log.e(TAG,"modDate = " + meta.getModDate());	  printBookmarksTree(pdfView.getTableOfContents(),"-");	}
public void printBookmarksTree(List<PdfDocument.Bookmark> tree,String sep){	  for (  PdfDocument.Bookmark b : tree) {	    Log.e(TAG,String.format("%s %s, p %d",sep,b.getTitle(),b.getPageIdx()));	    if (b.hasChildren()) {	      printBookmarksTree(b.getChildren(),sep + "-");	    }	  }	}
@Override public void onRequestPermissionsResult(int requestCode,@NonNull String permissions[],@NonNull int[] grantResults){	  if (requestCode == PERMISSION_CODE) {	    if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {	      launchPicker();	    }	  }	}
@Override public void onPageError(int page,Throwable t){	  Log.e(TAG,"Cannot load page " + page);	}
private MathUtils(){	}
public static int limit(int number,int between,int and){	  if (number <= between) {	    return between;	  }	  if (number >= and) {	    return and;	  }	  return number;	}
public static float limit(float number,float between,float and){	  if (number <= between) {	    return between;	  }	  if (number >= and) {	    return and;	  }	  return number;	}
public static float max(float number,float max){	  if (number > max) {	    return max;	  }	  return number;	}
public static float min(float number,float min){	  if (number < min) {	    return min;	  }	  return number;	}
public static int max(int number,int max){	  if (number > max) {	    return max;	  }	  return number;	}
public static int min(int number,int min){	  if (number < min) {	    return min;	  }	  return number;	}
static public int floor(float value){	  return (int)(value + BIG_ENOUGH_FLOOR) - BIG_ENOUGH_INT;	}
static public int ceil(float value){	  return (int)(value + BIG_ENOUGH_CEIL) - BIG_ENOUGH_INT;	}
private ArrayUtils(){	}
public static int[] deleteDuplicatedPages(int[] pages){	  List<Integer> result=new ArrayList<>();	  int lastInt=-1;	  for (  Integer currentInt : pages) {	    if (lastInt != currentInt) {	      result.add(currentInt);	    }	    lastInt=currentInt;	  }	  int[] arrayResult=new int[result.size()];	  for (int i=0; i < result.size(); i++) {	    arrayResult[i]=result.get(i);	  }	  return arrayResult;	}
public static int[] calculateIndexesInDuplicateArray(int[] originalUserPages){	  int[] result=new int[originalUserPages.length];	  if (originalUserPages.length == 0) {	    return result;	  }	  int index=0;	  result[0]=index;	  for (int i=1; i < originalUserPages.length; i++) {	    if (originalUserPages[i] != originalUserPages[i - 1]) {	      index++;	    }	    result[i]=index;	  }	  return result;	}
public static String arrayToString(int[] array){	  StringBuilder builder=new StringBuilder("[");	  for (int i=0; i < array.length; i++) {	    builder.append(array[i]);	    if (i != array.length - 1) {	      builder.append(",");	    }	  }	  builder.append("]");	  return builder.toString();	}
public PageSizeCalculator(FitPolicy fitPolicy,Size originalMaxWidthPageSize,Size originalMaxHeightPageSize,Size viewSize){	  this.fitPolicy=fitPolicy;	  this.originalMaxWidthPageSize=originalMaxWidthPageSize;	  this.originalMaxHeightPageSize=originalMaxHeightPageSize;	  this.viewSize=viewSize;	  calculateMaxPages();	}
public SizeF calculate(Size pageSize){	  if (pageSize.getWidth() <= 0 || pageSize.getHeight() <= 0) {	    return new SizeF(0,0);	  }	switch (fitPolicy) {	case HEIGHT:	    return fitHeight(pageSize,pageSize.getHeight() * heightRatio);	case BOTH:	  return fitBoth(pageSize,pageSize.getWidth() * widthRatio,pageSize.getHeight() * heightRatio);	default :	return fitWidth(pageSize,pageSize.getWidth() * widthRatio);	}	}
public SizeF getOptimalMaxWidthPageSize(){	  return optimalMaxWidthPageSize;	}
public SizeF getOptimalMaxHeightPageSize(){	  return optimalMaxHeightPageSize;	}
private void calculateMaxPages(){	switch (fitPolicy) {	case HEIGHT:	    optimalMaxHeightPageSize=fitHeight(originalMaxHeightPageSize,viewSize.getHeight());	  heightRatio=optimalMaxHeightPageSize.getHeight() / originalMaxHeightPageSize.getHeight();	optimalMaxWidthPageSize=fitHeight(originalMaxWidthPageSize,originalMaxWidthPageSize.getHeight() * heightRatio);	break;	case BOTH:	SizeF localOptimalMaxWidth=fitBoth(originalMaxWidthPageSize,viewSize.getWidth(),viewSize.getHeight());	float localWidthRatio=localOptimalMaxWidth.getWidth() / originalMaxWidthPageSize.getWidth();	this.optimalMaxHeightPageSize=fitBoth(originalMaxHeightPageSize,originalMaxHeightPageSize.getWidth() * localWidthRatio,viewSize.getHeight());	heightRatio=optimalMaxHeightPageSize.getHeight() / originalMaxHeightPageSize.getHeight();	optimalMaxWidthPageSize=fitBoth(originalMaxWidthPageSize,viewSize.getWidth(),originalMaxWidthPageSize.getHeight() * heightRatio);	widthRatio=optimalMaxWidthPageSize.getWidth() / originalMaxWidthPageSize.getWidth();	break;	default :	optimalMaxWidthPageSize=fitWidth(originalMaxWidthPageSize,viewSize.getWidth());	widthRatio=optimalMaxWidthPageSize.getWidth() / originalMaxWidthPageSize.getWidth();	optimalMaxHeightPageSize=fitWidth(originalMaxHeightPageSize,originalMaxHeightPageSize.getWidth() * widthRatio);	break;	}	}
private SizeF fitWidth(Size pageSize,float maxWidth){	  float w=pageSize.getWidth(), h=pageSize.getHeight();	  float ratio=w / h;	  w=maxWidth;	  h=(float)Math.floor(maxWidth / ratio);	  return new SizeF(w,h);	}
private SizeF fitHeight(Size pageSize,float maxHeight){	  float w=pageSize.getWidth(), h=pageSize.getHeight();	  float ratio=h / w;	  h=maxHeight;	  w=(float)Math.floor(maxHeight / ratio);	  return new SizeF(w,h);	}
private SizeF fitBoth(Size pageSize,float maxWidth,float maxHeight){	  float w=pageSize.getWidth(), h=pageSize.getHeight();	  float ratio=w / h;	  w=maxWidth;	  h=(float)Math.floor(maxWidth / ratio);	  if (h > maxHeight) {	    h=maxHeight;	    w=(float)Math.floor(maxHeight * ratio);	  }	  return new SizeF(w,h);	}
private FileUtils(){	}
public static File fileFromAsset(Context context,String assetName) throws IOException {	  File outFile=new File(context.getCacheDir(),assetName + "-pdfview.pdf");	  if (assetName.contains("/")) {	    outFile.getParentFile().mkdirs();	  }	  copy(context.getAssets().open(assetName),outFile);	  return outFile;	}
public static void copy(InputStream inputStream,File output) throws IOException {	  OutputStream outputStream=null;	  try {	    outputStream=new FileOutputStream(output);	    int read=0;	    byte[] bytes=new byte[1024];	    while ((read=inputStream.read(bytes)) != -1) {	      outputStream.write(bytes,0,read);	    }	  }	  finally {	    try {	      if (inputStream != null) {	        inputStream.close();	      }	    }	  finally {	      if (outputStream != null) {	        outputStream.close();	      }	    }	  }	}
public static int getDP(Context context,int dp){	  return (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,dp,context.getResources().getDisplayMetrics());	}
public static byte[] toByteArray(InputStream inputStream) throws IOException {	  ByteArrayOutputStream os=new ByteArrayOutputStream();	  byte[] buffer=new byte[DEFAULT_BUFFER_SIZE];	  int n;	  while (-1 != (n=inputStream.read(buffer))) {	    os.write(buffer,0,n);	  }	  return os.toByteArray();	}
public CacheManager(){	  activeCache=new PriorityQueue<>(CACHE_SIZE,orderComparator);	  passiveCache=new PriorityQueue<>(CACHE_SIZE,orderComparator);	  thumbnails=new ArrayList<>();	}
public void cachePart(PagePart part){	synchronized (passiveActiveLock) {	    makeAFreeSpace();	    activeCache.offer(part);	  }	}
public void makeANewSet(){	synchronized (passiveActiveLock) {	    passiveCache.addAll(activeCache);	    activeCache.clear();	  }	}
private void makeAFreeSpace(){	synchronized (passiveActiveLock) {	    while ((activeCache.size() + passiveCache.size()) >= CACHE_SIZE && !passiveCache.isEmpty()) {	      PagePart part=passiveCache.poll();	      part.getRenderedBitmap().recycle();	    }	    while ((activeCache.size() + passiveCache.size()) >= CACHE_SIZE && !activeCache.isEmpty()) {	      activeCache.poll().getRenderedBitmap().recycle();	    }	  }	}
public void cacheThumbnail(PagePart part){	synchronized (thumbnails) {	    while (thumbnails.size() >= THUMBNAILS_CACHE_SIZE) {	      thumbnails.remove(0).getRenderedBitmap().recycle();	    }	    addWithoutDuplicates(thumbnails,part);	  }	}
public boolean upPartIfContained(int page,RectF pageRelativeBounds,int toOrder){	  PagePart fakePart=new PagePart(page,null,pageRelativeBounds,false,0);	  PagePart found;	synchronized (passiveActiveLock) {	    if ((found=find(passiveCache,fakePart)) != null) {	      passiveCache.remove(found);	      found.setCacheOrder(toOrder);	      activeCache.offer(found);	      return true;	    }	    return find(activeCache,fakePart) != null;	  }	}
public boolean containsThumbnail(int page,RectF pageRelativeBounds){	  PagePart fakePart=new PagePart(page,null,pageRelativeBounds,true,0);	synchronized (thumbnails) {	    for (    PagePart part : thumbnails) {	      if (part.equals(fakePart)) {	        return true;	      }	    }	    return false;	  }	}
private void addWithoutDuplicates(Collection<PagePart> collection,PagePart newPart){	  for (  PagePart part : collection) {	    if (part.equals(newPart)) {	      newPart.getRenderedBitmap().recycle();	      return;	    }	  }	  collection.add(newPart);	}
@Nullable private static PagePart find(PriorityQueue<PagePart> vector,PagePart fakePart){	  for (  PagePart part : vector) {	    if (part.equals(fakePart)) {	      return part;	    }	  }	  return null;	}
public List<PagePart> getPageParts(){	synchronized (passiveActiveLock) {	    List<PagePart> parts=new ArrayList<>(passiveCache);	    parts.addAll(activeCache);	    return parts;	  }	}
public List<PagePart> getThumbnails(){	synchronized (thumbnails) {	    return thumbnails;	  }	}
public void recycle(){	synchronized (passiveActiveLock) {	    for (    PagePart part : passiveCache) {	      part.getRenderedBitmap().recycle();	    }	    passiveCache.clear();	    for (    PagePart part : activeCache) {	      part.getRenderedBitmap().recycle();	    }	    activeCache.clear();	  }	synchronized (thumbnails) {	    for (    PagePart part : thumbnails) {	      part.getRenderedBitmap().recycle();	    }	    thumbnails.clear();	  }	}
public AnimationManager(PDFView pdfView){	  this.pdfView=pdfView;	  scroller=new OverScroller(pdfView.getContext());	}
public void startXAnimation(float xFrom,float xTo){	  stopAll();	  animation=ValueAnimator.ofFloat(xFrom,xTo);	  XAnimation xAnimation=new XAnimation();	  animation.setInterpolator(new DecelerateInterpolator());	  animation.addUpdateListener(xAnimation);	  animation.addListener(xAnimation);	  animation.setDuration(400);	  animation.start();	}
public void startYAnimation(float yFrom,float yTo){	  stopAll();	  animation=ValueAnimator.ofFloat(yFrom,yTo);	  YAnimation yAnimation=new YAnimation();	  animation.setInterpolator(new DecelerateInterpolator());	  animation.addUpdateListener(yAnimation);	  animation.addListener(yAnimation);	  animation.setDuration(400);	  animation.start();	}
public void startZoomAnimation(float centerX,float centerY,float zoomFrom,float zoomTo){	  stopAll();	  animation=ValueAnimator.ofFloat(zoomFrom,zoomTo);	  animation.setInterpolator(new DecelerateInterpolator());	  ZoomAnimation zoomAnim=new ZoomAnimation(centerX,centerY);	  animation.addUpdateListener(zoomAnim);	  animation.addListener(zoomAnim);	  animation.setDuration(400);	  animation.start();	}
public void startFlingAnimation(int startX,int startY,int velocityX,int velocityY,int minX,int maxX,int minY,int maxY){	  stopAll();	  flinging=true;	  scroller.fling(startX,startY,velocityX,velocityY,minX,maxX,minY,maxY);	}
public void startPageFlingAnimation(float targetOffset){	  if (pdfView.isSwipeVertical()) {	    startYAnimation(pdfView.getCurrentYOffset(),targetOffset);	  }	 else {	    startXAnimation(pdfView.getCurrentXOffset(),targetOffset);	  }	  pageFlinging=true;	}
void computeFling(){	  if (scroller.computeScrollOffset()) {	    pdfView.moveTo(scroller.getCurrX(),scroller.getCurrY());	    pdfView.loadPageByOffset();	  }	 else   if (flinging) {	    flinging=false;	    pdfView.loadPages();	    hideHandle();	    pdfView.performPageSnap();	  }	}
public void stopAll(){	  if (animation != null) {	    animation.cancel();	    animation=null;	  }	  stopFling();	}
public void stopFling(){	  flinging=false;	  scroller.forceFinished(true);	}
public boolean isFlinging(){	  return flinging || pageFlinging;	}
private void hideHandle(){	  if (pdfView.getScrollHandle() != null) {	    pdfView.getScrollHandle().hideDelayed();	  }	}
PagesLoader(PDFView pdfView){	  this.pdfView=pdfView;	  this.preloadOffset=Util.getDP(pdfView.getContext(),PRELOAD_OFFSET);	}
private void getPageColsRows(GridSize grid,int pageIndex){	  SizeF size=pdfView.pdfFile.getPageSize(pageIndex);	  float ratioX=1f / size.getWidth();	  float ratioY=1f / size.getHeight();	  final float partHeight=(Constants.PART_SIZE * ratioY) / pdfView.getZoom();	  final float partWidth=(Constants.PART_SIZE * ratioX) / pdfView.getZoom();	  grid.rows=MathUtils.ceil(1f / partHeight);	  grid.cols=MathUtils.ceil(1f / partWidth);	}
private Holder getPageAndCoordsByOffset(Holder holder,GridSize grid,float localXOffset,float localYOffset,boolean endOffset){	  float fixedXOffset=-MathUtils.max(localXOffset,0);	  float fixedYOffset=-MathUtils.max(localYOffset,0);	  float offset=pdfView.isSwipeVertical() ? fixedYOffset : fixedXOffset;	  holder.page=pdfView.pdfFile.getPageAtOffset(offset,pdfView.getZoom());	  getPageColsRows(grid,holder.page);	  SizeF scaledPageSize=pdfView.pdfFile.getScaledPageSize(holder.page,pdfView.getZoom());	  float rowHeight=scaledPageSize.getHeight() / grid.rows;	  float colWidth=scaledPageSize.getWidth() / grid.cols;	  float row, col;	  float secondaryOffset=pdfView.pdfFile.getSecondaryPageOffset(holder.page,pdfView.getZoom());	  if (pdfView.isSwipeVertical()) {	    row=Math.abs(fixedYOffset - pdfView.pdfFile.getPageOffset(holder.page,pdfView.getZoom())) / rowHeight;	    col=MathUtils.min(fixedXOffset - secondaryOffset,0) / colWidth;	  }	 else {	    col=Math.abs(fixedXOffset - pdfView.pdfFile.getPageOffset(holder.page,pdfView.getZoom())) / colWidth;	    row=MathUtils.min(fixedYOffset - secondaryOffset,0) / rowHeight;	  }	  if (endOffset) {	    holder.row=MathUtils.ceil(row);	    holder.col=MathUtils.ceil(col);	  }	 else {	    holder.row=MathUtils.floor(row);	    holder.col=MathUtils.floor(col);	  }	  return holder;	}
private void calculatePartSize(GridSize grid){	  pageRelativePartWidth=1f / (float)grid.cols;	  pageRelativePartHeight=1f / (float)grid.rows;	  partRenderWidth=Constants.PART_SIZE / pageRelativePartWidth;	  partRenderHeight=Constants.PART_SIZE / pageRelativePartHeight;	}
private void loadVisible(){	  int parts=0;	  float scaledPreloadOffset=preloadOffset * pdfView.getZoom();	  float firstXOffset=-xOffset + scaledPreloadOffset;	  float lastXOffset=-xOffset - pdfView.getWidth() - scaledPreloadOffset;	  float firstYOffset=-yOffset + scaledPreloadOffset;	  float lastYOffset=-yOffset - pdfView.getHeight() - scaledPreloadOffset;	  getPageAndCoordsByOffset(firstHolder,firstGrid,firstXOffset,firstYOffset,false);	  getPageAndCoordsByOffset(lastHolder,lastGrid,lastXOffset,lastYOffset,true);	  for (int i=firstHolder.page; i <= lastHolder.page; i++) {	    loadThumbnail(i);	  }	  int pagesCount=lastHolder.page - firstHolder.page + 1;	  for (int page=firstHolder.page; page <= lastHolder.page && parts < CACHE_SIZE; page++) {	    if (page == firstHolder.page && pagesCount > 1) {	      parts+=loadPageEnd(firstHolder,firstGrid,CACHE_SIZE - parts);	    }	 else     if (page == lastHolder.page && pagesCount > 1) {	      parts+=loadPageStart(lastHolder,lastGrid,CACHE_SIZE - parts);	    }	 else     if (pagesCount == 1) {	      parts+=loadPageCenter(firstHolder,lastHolder,firstGrid,CACHE_SIZE - parts);	    }	 else {	      getPageColsRows(middleGrid,page);	      parts+=loadWholePage(page,middleGrid,CACHE_SIZE - parts);	    }	  }	}
private int loadWholePage(int page,GridSize grid,int nbOfPartsLoadable){	  calculatePartSize(grid);	  return loadPage(page,0,grid.rows - 1,0,grid.cols - 1,nbOfPartsLoadable);	}
private int loadPageCenter(Holder firstHolder,Holder lastHolder,GridSize grid,int nbOfPartsLoadable){	  calculatePartSize(grid);	  return loadPage(firstHolder.page,firstHolder.row,lastHolder.row,firstHolder.col,lastHolder.col,nbOfPartsLoadable);	}
private int loadPageEnd(Holder holder,GridSize grid,int nbOfPartsLoadable){	  calculatePartSize(grid);	  if (pdfView.isSwipeVertical()) {	    int firstRow=holder.row;	    return loadPage(holder.page,firstRow,grid.rows - 1,0,grid.cols - 1,nbOfPartsLoadable);	  }	 else {	    int firstCol=holder.col;	    return loadPage(holder.page,0,grid.rows - 1,firstCol,grid.cols - 1,nbOfPartsLoadable);	  }	}
private int loadPageStart(Holder holder,GridSize grid,int nbOfPartsLoadable){	  calculatePartSize(grid);	  if (pdfView.isSwipeVertical()) {	    int lastRow=holder.row;	    return loadPage(holder.page,0,lastRow,0,grid.cols - 1,nbOfPartsLoadable);	  }	 else {	    int lastCol=holder.col;	    return loadPage(holder.page,0,grid.rows - 1,0,lastCol,nbOfPartsLoadable);	  }	}
private int loadPage(int page,int firstRow,int lastRow,int firstCol,int lastCol,int nbOfPartsLoadable){	  int loaded=0;	  for (int row=firstRow; row <= lastRow; row++) {	    for (int col=firstCol; col <= lastCol; col++) {	      if (loadCell(page,row,col,pageRelativePartWidth,pageRelativePartHeight)) {	        loaded++;	      }	      if (loaded >= nbOfPartsLoadable) {	        return loaded;	      }	    }	  }	  return loaded;	}
private boolean loadCell(int page,int row,int col,float pageRelativePartWidth,float pageRelativePartHeight){	  float relX=pageRelativePartWidth * col;	  float relY=pageRelativePartHeight * row;	  float relWidth=pageRelativePartWidth;	  float relHeight=pageRelativePartHeight;	  float renderWidth=partRenderWidth;	  float renderHeight=partRenderHeight;	  if (relX + relWidth > 1) {	    relWidth=1 - relX;	  }	  if (relY + relHeight > 1) {	    relHeight=1 - relY;	  }	  renderWidth*=relWidth;	  renderHeight*=relHeight;	  RectF pageRelativeBounds=new RectF(relX,relY,relX + relWidth,relY + relHeight);	  if (renderWidth > 0 && renderHeight > 0) {	    if (!pdfView.cacheManager.upPartIfContained(page,pageRelativeBounds,cacheOrder)) {	      pdfView.renderingHandler.addRenderingTask(page,renderWidth,renderHeight,pageRelativeBounds,false,cacheOrder,pdfView.isBestQuality(),pdfView.isAnnotationRendering());	    }	    cacheOrder++;	    return true;	  }	  return false;	}
private void loadThumbnail(int page){	  SizeF pageSize=pdfView.pdfFile.getPageSize(page);	  float thumbnailWidth=pageSize.getWidth() * Constants.THUMBNAIL_RATIO;	  float thumbnailHeight=pageSize.getHeight() * Constants.THUMBNAIL_RATIO;	  if (!pdfView.cacheManager.containsThumbnail(page,thumbnailRect)) {	    pdfView.renderingHandler.addRenderingTask(page,thumbnailWidth,thumbnailHeight,thumbnailRect,true,0,pdfView.isBestQuality(),pdfView.isAnnotationRendering());	  }	}
void loadPages(){	  cacheOrder=1;	  xOffset=-MathUtils.max(pdfView.getCurrentXOffset(),0);	  yOffset=-MathUtils.max(pdfView.getCurrentYOffset(),0);	  loadVisible();	}
PdfFile(PdfiumCore pdfiumCore,PdfDocument pdfDocument,FitPolicy pageFitPolicy,Size viewSize,int[] originalUserPages,boolean isVertical,int spacing,boolean autoSpacing){	  this.pdfiumCore=pdfiumCore;	  this.pdfDocument=pdfDocument;	  this.pageFitPolicy=pageFitPolicy;	  this.originalUserPages=originalUserPages;	  this.isVertical=isVertical;	  this.spacingPx=spacing;	  this.autoSpacing=autoSpacing;	  setup(viewSize);	}
private void setup(Size viewSize){	  if (originalUserPages != null) {	    pagesCount=originalUserPages.length;	  }	 else {	    pagesCount=pdfiumCore.getPageCount(pdfDocument);	  }	  for (int i=0; i < pagesCount; i++) {	    Size pageSize=pdfiumCore.getPageSize(pdfDocument,documentPage(i));	    if (pageSize.getWidth() > originalMaxWidthPageSize.getWidth()) {	      originalMaxWidthPageSize=pageSize;	    }	    if (pageSize.getHeight() > originalMaxHeightPageSize.getHeight()) {	      originalMaxHeightPageSize=pageSize;	    }	    originalPageSizes.add(pageSize);	  }	  recalculatePageSizes(viewSize);	}
public void recalculatePageSizes(Size viewSize){	  pageSizes.clear();	  PageSizeCalculator calculator=new PageSizeCalculator(pageFitPolicy,originalMaxWidthPageSize,originalMaxHeightPageSize,viewSize);	  maxWidthPageSize=calculator.getOptimalMaxWidthPageSize();	  maxHeightPageSize=calculator.getOptimalMaxHeightPageSize();	  for (  Size size : originalPageSizes) {	    pageSizes.add(calculator.calculate(size));	  }	  if (autoSpacing) {	    prepareAutoSpacing(viewSize);	  }	  prepareDocLen();	  preparePagesOffset();	}
public int getPagesCount(){	  return pagesCount;	}
public SizeF getPageSize(int pageIndex){	  int docPage=documentPage(pageIndex);	  if (docPage < 0) {	    return new SizeF(0,0);	  }	  return pageSizes.get(pageIndex);	}
public SizeF getScaledPageSize(int pageIndex,float zoom){	  SizeF size=getPageSize(pageIndex);	  return new SizeF(size.getWidth() * zoom,size.getHeight() * zoom);	}
public SizeF getMaxPageSize(){	  return isVertical ? maxWidthPageSize : maxHeightPageSize;	}
public float getMaxPageWidth(){	  return getMaxPageSize().getWidth();	}
public float getMaxPageHeight(){	  return getMaxPageSize().getHeight();	}
private void prepareAutoSpacing(Size viewSize){	  pageSpacing.clear();	  for (int i=0; i < getPagesCount(); i++) {	    SizeF pageSize=pageSizes.get(i);	    float spacing=Math.max(0,isVertical ? viewSize.getHeight() - pageSize.getHeight() : viewSize.getWidth() - pageSize.getWidth());	    if (i < getPagesCount() - 1) {	      spacing+=spacingPx;	    }	    pageSpacing.add(spacing);	  }	}
private void prepareDocLen(){	  float length=0;	  for (int i=0; i < getPagesCount(); i++) {	    SizeF pageSize=pageSizes.get(i);	    length+=isVertical ? pageSize.getHeight() : pageSize.getWidth();	    if (autoSpacing) {	      length+=pageSpacing.get(i);	    }	 else     if (i < getPagesCount() - 1) {	      length+=spacingPx;	    }	  }	  documentLength=length;	}
private void preparePagesOffset(){	  pageOffsets.clear();	  float offset=0;	  for (int i=0; i < getPagesCount(); i++) {	    SizeF pageSize=pageSizes.get(i);	    float size=isVertical ? pageSize.getHeight() : pageSize.getWidth();	    if (autoSpacing) {	      offset+=pageSpacing.get(i) / 2f;	      if (i == 0) {	        offset-=spacingPx / 2f;	      }	 else       if (i == getPagesCount() - 1) {	        offset+=spacingPx / 2f;	      }	      pageOffsets.add(offset);	      offset+=size + pageSpacing.get(i) / 2f;	    }	 else {	      pageOffsets.add(offset);	      offset+=size + spacingPx;	    }	  }	}
public float getDocLen(float zoom){	  return documentLength * zoom;	}
public float getPageLength(int pageIndex,float zoom){	  SizeF size=getPageSize(pageIndex);	  return (isVertical ? size.getHeight() : size.getWidth()) * zoom;	}
public float getPageSpacing(int pageIndex,float zoom){	  float spacing=autoSpacing ? pageSpacing.get(pageIndex) : spacingPx;	  return spacing * zoom;	}
public float getPageOffset(int pageIndex,float zoom){	  int docPage=documentPage(pageIndex);	  if (docPage < 0) {	    return 0;	  }	  return pageOffsets.get(pageIndex) * zoom;	}
public float getSecondaryPageOffset(int pageIndex,float zoom){	  SizeF pageSize=getPageSize(pageIndex);	  if (isVertical) {	    float maxWidth=getMaxPageWidth();	    return zoom * (maxWidth - pageSize.getWidth()) / 2;	  }	 else {	    float maxHeight=getMaxPageHeight();	    return zoom * (maxHeight - pageSize.getHeight()) / 2;	  }	}
public int getPageAtOffset(float offset,float zoom){	  int currentPage=0;	  for (int i=0; i < getPagesCount(); i++) {	    float off=pageOffsets.get(i) * zoom - getPageSpacing(i,zoom) / 2f;	    if (off >= offset) {	      break;	    }	    currentPage++;	  }	  return --currentPage >= 0 ? currentPage : 0;	}
public boolean openPage(int pageIndex) throws PageRenderingException {	  int docPage=documentPage(pageIndex);	  if (docPage < 0) {	    return false;	  }	synchronized (lock) {	    if (openedPages.indexOfKey(docPage) < 0) {	      try {	        pdfiumCore.openPage(pdfDocument,docPage);	        openedPages.put(docPage,true);	        return true;	      }	 catch (      Exception e) {	        openedPages.put(docPage,false);	        throw new PageRenderingException(pageIndex,e);	      }	    }	    return false;	  }	}
public boolean pageHasError(int pageIndex){	  int docPage=documentPage(pageIndex);	  return !openedPages.get(docPage,false);	}
public void renderPageBitmap(Bitmap bitmap,int pageIndex,Rect bounds,boolean annotationRendering){	  int docPage=documentPage(pageIndex);	  pdfiumCore.renderPageBitmap(pdfDocument,bitmap,docPage,bounds.left,bounds.top,bounds.width(),bounds.height(),annotationRendering);	}
public PdfDocument.Meta getMetaData(){	  if (pdfDocument == null) {	    return null;	  }	  return pdfiumCore.getDocumentMeta(pdfDocument);	}
public List<PdfDocument.Bookmark> getBookmarks(){	  if (pdfDocument == null) {	    return new ArrayList<>();	  }	  return pdfiumCore.getTableOfContents(pdfDocument);	}
public List<PdfDocument.Link> getPageLinks(int pageIndex){	  int docPage=documentPage(pageIndex);	  return pdfiumCore.getPageLinks(pdfDocument,docPage);	}
public RectF mapRectToDevice(int pageIndex,int startX,int startY,int sizeX,int sizeY,RectF rect){	  int docPage=documentPage(pageIndex);	  return pdfiumCore.mapRectToDevice(pdfDocument,docPage,startX,startY,sizeX,sizeY,0,rect);	}
public void dispose(){	  if (pdfiumCore != null && pdfDocument != null) {	    pdfiumCore.closeDocument(pdfDocument);	  }	  pdfDocument=null;	  originalUserPages=null;	}
public int determineValidPageNumberFrom(int userPage){	  if (userPage <= 0) {	    return 0;	  }	  if (originalUserPages != null) {	    if (userPage >= originalUserPages.length) {	      return originalUserPages.length - 1;	    }	  }	 else {	    if (userPage >= getPagesCount()) {	      return getPagesCount() - 1;	    }	  }	  return userPage;	}
public int documentPage(int userPage){	  int documentPage=userPage;	  if (originalUserPages != null) {	    if (userPage < 0 || userPage >= originalUserPages.length) {	      return -1;	    }	 else {	      documentPage=originalUserPages[userPage];	    }	  }	  if (documentPage < 0 || userPage >= getPagesCount()) {	    return -1;	  }	  return documentPage;	}
DragPinchManager(PDFView pdfView,AnimationManager animationManager){	  this.pdfView=pdfView;	  this.animationManager=animationManager;	  gestureDetector=new GestureDetector(pdfView.getContext(),this);	  scaleGestureDetector=new ScaleGestureDetector(pdfView.getContext(),this);	  pdfView.setOnTouchListener(this);	}
void enable(){	  enabled=true;	}
void disable(){	  enabled=false;	}
@Override public boolean onSingleTapConfirmed(MotionEvent e){	  boolean onTapHandled=pdfView.callbacks.callOnTap(e);	  boolean linkTapped=checkLinkTapped(e.getX(),e.getY());	  if (!onTapHandled && !linkTapped) {	    ScrollHandle ps=pdfView.getScrollHandle();	    if (ps != null && !pdfView.documentFitsView()) {	      if (!ps.shown()) {	        ps.show();	      }	 else {	        ps.hide();	      }	    }	  }	  pdfView.performClick();	  return true;	}
private boolean checkLinkTapped(float x,float y){	  PdfFile pdfFile=pdfView.pdfFile;	  float mappedX=-pdfView.getCurrentXOffset() + x;	  float mappedY=-pdfView.getCurrentYOffset() + y;	  int page=pdfFile.getPageAtOffset(pdfView.isSwipeVertical() ? mappedY : mappedX,pdfView.getZoom());	  SizeF pageSize=pdfFile.getScaledPageSize(page,pdfView.getZoom());	  int pageX, pageY;	  if (pdfView.isSwipeVertical()) {	    pageX=(int)pdfFile.getSecondaryPageOffset(page,pdfView.getZoom());	    pageY=(int)pdfFile.getPageOffset(page,pdfView.getZoom());	  }	 else {	    pageY=(int)pdfFile.getSecondaryPageOffset(page,pdfView.getZoom());	    pageX=(int)pdfFile.getPageOffset(page,pdfView.getZoom());	  }	  for (  PdfDocument.Link link : pdfFile.getPageLinks(page)) {	    RectF mapped=pdfFile.mapRectToDevice(page,pageX,pageY,(int)pageSize.getWidth(),(int)pageSize.getHeight(),link.getBounds());	    mapped.sort();	    if (mapped.contains(mappedX,mappedY)) {	      pdfView.callbacks.callLinkHandler(new LinkTapEvent(x,y,mappedX,mappedY,mapped,link));	      return true;	    }	  }	  return false;	}
private void startPageFling(MotionEvent downEvent,MotionEvent ev,float velocityX,float velocityY){	  if (!checkDoPageFling(velocityX,velocityY)) {	    return;	  }	  int direction;	  if (pdfView.isSwipeVertical()) {	    direction=velocityY > 0 ? -1 : 1;	  }	 else {	    direction=velocityX > 0 ? -1 : 1;	  }	  float delta=pdfView.isSwipeVertical() ? ev.getY() - downEvent.getY() : ev.getX() - downEvent.getX();	  float offsetX=pdfView.getCurrentXOffset() - delta * pdfView.getZoom();	  float offsetY=pdfView.getCurrentYOffset() - delta * pdfView.getZoom();	  int startingPage=pdfView.findFocusPage(offsetX,offsetY);	  int targetPage=Math.max(0,Math.min(pdfView.getPageCount() - 1,startingPage + direction));	  SnapEdge edge=pdfView.findSnapEdge(targetPage);	  float offset=pdfView.snapOffsetForPage(targetPage,edge);	  animationManager.startPageFlingAnimation(-offset);	}
@Override public boolean onDoubleTap(MotionEvent e){	  if (!pdfView.isDoubletapEnabled()) {	    return false;	  }	  if (pdfView.getZoom() < pdfView.getMidZoom()) {	    pdfView.zoomWithAnimation(e.getX(),e.getY(),pdfView.getMidZoom());	  }	 else   if (pdfView.getZoom() < pdfView.getMaxZoom()) {	    pdfView.zoomWithAnimation(e.getX(),e.getY(),pdfView.getMaxZoom());	  }	 else {	    pdfView.resetZoomWithAnimation();	  }	  return true;	}
@Override public boolean onDoubleTapEvent(MotionEvent e){	  return false;	}
@Override public boolean onDown(MotionEvent e){	  animationManager.stopFling();	  return true;	}
@Override public void onShowPress(MotionEvent e){	}
@Override public boolean onSingleTapUp(MotionEvent e){	  return false;	}
@Override public boolean onScroll(MotionEvent e1,MotionEvent e2,float distanceX,float distanceY){	  scrolling=true;	  if (pdfView.isZooming() || pdfView.isSwipeEnabled()) {	    pdfView.moveRelativeTo(-distanceX,-distanceY);	  }	  if (!scaling || pdfView.doRenderDuringScale()) {	    pdfView.loadPageByOffset();	  }	  return true;	}
private void onScrollEnd(MotionEvent event){	  pdfView.loadPages();	  hideHandle();	  if (!animationManager.isFlinging()) {	    pdfView.performPageSnap();	  }	}
@Override public void onLongPress(MotionEvent e){	  pdfView.callbacks.callOnLongPress(e);	}
@Override public boolean onFling(MotionEvent e1,MotionEvent e2,float velocityX,float velocityY){	  if (!pdfView.isSwipeEnabled()) {	    return false;	  }	  if (pdfView.doPageFling()) {	    if (pdfView.pageFillsScreen()) {	      onBoundedFling(velocityX,velocityY);	    }	 else {	      startPageFling(e1,e2,velocityX,velocityY);	    }	    return true;	  }	  int xOffset=(int)pdfView.getCurrentXOffset();	  int yOffset=(int)pdfView.getCurrentYOffset();	  float minX, minY;	  PdfFile pdfFile=pdfView.pdfFile;	  if (pdfView.isSwipeVertical()) {	    minX=-(pdfView.toCurrentScale(pdfFile.getMaxPageWidth()) - pdfView.getWidth());	    minY=-(pdfFile.getDocLen(pdfView.getZoom()) - pdfView.getHeight());	  }	 else {	    minX=-(pdfFile.getDocLen(pdfView.getZoom()) - pdfView.getWidth());	    minY=-(pdfView.toCurrentScale(pdfFile.getMaxPageHeight()) - pdfView.getHeight());	  }	  animationManager.startFlingAnimation(xOffset,yOffset,(int)(velocityX),(int)(velocityY),(int)minX,0,(int)minY,0);	  return true;	}
private void onBoundedFling(float velocityX,float velocityY){	  int xOffset=(int)pdfView.getCurrentXOffset();	  int yOffset=(int)pdfView.getCurrentYOffset();	  PdfFile pdfFile=pdfView.pdfFile;	  float pageStart=-pdfFile.getPageOffset(pdfView.getCurrentPage(),pdfView.getZoom());	  float pageEnd=pageStart - pdfFile.getPageLength(pdfView.getCurrentPage(),pdfView.getZoom());	  float minX, minY, maxX, maxY;	  if (pdfView.isSwipeVertical()) {	    minX=-(pdfView.toCurrentScale(pdfFile.getMaxPageWidth()) - pdfView.getWidth());	    minY=pageEnd + pdfView.getHeight();	    maxX=0;	    maxY=pageStart;	  }	 else {	    minX=pageEnd + pdfView.getWidth();	    minY=-(pdfView.toCurrentScale(pdfFile.getMaxPageHeight()) - pdfView.getHeight());	    maxX=pageStart;	    maxY=0;	  }	  animationManager.startFlingAnimation(xOffset,yOffset,(int)(velocityX),(int)(velocityY),(int)minX,(int)maxX,(int)minY,(int)maxY);	}
@Override public boolean onScale(ScaleGestureDetector detector){	  float dr=detector.getScaleFactor();	  float wantedZoom=pdfView.getZoom() * dr;	  if (wantedZoom < MINIMUM_ZOOM) {	    dr=MINIMUM_ZOOM / pdfView.getZoom();	  }	 else   if (wantedZoom > MAXIMUM_ZOOM) {	    dr=MAXIMUM_ZOOM / pdfView.getZoom();	  }	  pdfView.zoomCenteredRelativeTo(dr,new PointF(detector.getFocusX(),detector.getFocusY()));	  return true;	}
@Override public boolean onScaleBegin(ScaleGestureDetector detector){	  scaling=true;	  return true;	}
@Override public void onScaleEnd(ScaleGestureDetector detector){	  pdfView.loadPages();	  hideHandle();	  scaling=false;	}
@Override public boolean onTouch(View v,MotionEvent event){	  if (!enabled) {	    return false;	  }	  boolean retVal=scaleGestureDetector.onTouchEvent(event);	  retVal=gestureDetector.onTouchEvent(event) || retVal;	  if (event.getAction() == MotionEvent.ACTION_UP) {	    if (scrolling) {	      scrolling=false;	      onScrollEnd(event);	    }	  }	  return retVal;	}
private void hideHandle(){	  ScrollHandle scrollHandle=pdfView.getScrollHandle();	  if (scrollHandle != null && scrollHandle.shown()) {	    scrollHandle.hideDelayed();	  }	}
private boolean checkDoPageFling(float velocityX,float velocityY){	  float absX=Math.abs(velocityX);	  float absY=Math.abs(velocityY);	  return pdfView.isSwipeVertical() ? absY > absX : absX > absY;	}
DecodingAsyncTask(DocumentSource docSource,String password,int[] userPages,PDFView pdfView,PdfiumCore pdfiumCore){	  this.docSource=docSource;	  this.userPages=userPages;	  this.cancelled=false;	  this.pdfView=pdfView;	  this.password=password;	  this.pdfiumCore=pdfiumCore;	}
@Override protected Throwable doInBackground(Void... params){	  try {	    PdfDocument pdfDocument=docSource.createDocument(pdfView.getContext(),pdfiumCore,password);	    pdfFile=new PdfFile(pdfiumCore,pdfDocument,pdfView.getPageFitPolicy(),getViewSize(),userPages,pdfView.isSwipeVertical(),pdfView.getSpacingPx(),pdfView.doAutoSpacing());	    return null;	  }	 catch (  Throwable t) {	    return t;	  }	}
private Size getViewSize(){	  return new Size(pdfView.getWidth(),pdfView.getHeight());	}
@Override protected void onPostExecute(Throwable t){	  if (t != null) {	    pdfView.loadError(t);	    return;	  }	  if (!cancelled) {	    pdfView.loadComplete(pdfFile);	  }	}
@Override protected void onCancelled(){	  cancelled=true;	}
ScrollHandle getScrollHandle(){	  return scrollHandle;	}
public PDFView(Context context,AttributeSet set){	  super(context,set);	  renderingHandlerThread=new HandlerThread("PDF renderer");	  if (isInEditMode()) {	    return;	  }	  cacheManager=new CacheManager();	  animationManager=new AnimationManager(this);	  dragPinchManager=new DragPinchManager(this,animationManager);	  pagesLoader=new PagesLoader(this);	  paint=new Paint();	  debugPaint=new Paint();	  debugPaint.setStyle(Style.STROKE);	  pdfiumCore=new PdfiumCore(context);	  setWillNotDraw(false);	}
private void load(DocumentSource docSource,String password){	  load(docSource,password,null);	}
private void load(DocumentSource docSource,String password,int[] userPages){	  if (!recycled) {	    throw new IllegalStateException("Don't call load on a PDF View without recycling it first.");	  }	  recycled=false;	  decodingAsyncTask=new DecodingAsyncTask(docSource,password,userPages,this,pdfiumCore);	  decodingAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);	}
public void jumpTo(int page,boolean withAnimation){	  if (pdfFile == null) {	    return;	  }	  page=pdfFile.determineValidPageNumberFrom(page);	  float offset=page == 0 ? 0 : -pdfFile.getPageOffset(page,zoom);	  if (swipeVertical) {	    if (withAnimation) {	      animationManager.startYAnimation(currentYOffset,offset);	    }	 else {	      moveTo(currentXOffset,offset);	    }	  }	 else {	    if (withAnimation) {	      animationManager.startXAnimation(currentXOffset,offset);	    }	 else {	      moveTo(offset,currentYOffset);	    }	  }	  showPage(page);	}
public void jumpTo(int page){	  jumpTo(page,false);	}
void showPage(int pageNb){	  if (recycled) {	    return;	  }	  pageNb=pdfFile.determineValidPageNumberFrom(pageNb);	  currentPage=pageNb;	  loadPages();	  if (scrollHandle != null && !documentFitsView()) {	    scrollHandle.setPageNum(currentPage + 1);	  }	  callbacks.callOnPageChange(currentPage,pdfFile.getPagesCount());	}
public float getPositionOffset(){	  float offset;	  if (swipeVertical) {	    offset=-currentYOffset / (pdfFile.getDocLen(zoom) - getHeight());	  }	 else {	    offset=-currentXOffset / (pdfFile.getDocLen(zoom) - getWidth());	  }	  return MathUtils.limit(offset,0,1);	}
public void setPositionOffset(float progress,boolean moveHandle){	  if (swipeVertical) {	    moveTo(currentXOffset,(-pdfFile.getDocLen(zoom) + getHeight()) * progress,moveHandle);	  }	 else {	    moveTo((-pdfFile.getDocLen(zoom) + getWidth()) * progress,currentYOffset,moveHandle);	  }	  loadPageByOffset();	}
public void setPositionOffset(float progress){	  setPositionOffset(progress,true);	}
public void stopFling(){	  animationManager.stopFling();	}
public int getPageCount(){	  if (pdfFile == null) {	    return 0;	  }	  return pdfFile.getPagesCount();	}
public void setSwipeEnabled(boolean enableSwipe){	  this.enableSwipe=enableSwipe;	}
public void setNightMode(boolean nightMode){	  this.nightMode=nightMode;	  if (nightMode) {	    ColorMatrix colorMatrixInverted=new ColorMatrix(new float[]{-1,0,0,0,255,0,-1,0,0,255,0,0,-1,0,255,0,0,0,1,0});	    ColorMatrixColorFilter filter=new ColorMatrixColorFilter(colorMatrixInverted);	    paint.setColorFilter(filter);	  }	 else {	    paint.setColorFilter(null);	  }	}
void enableDoubletap(boolean enableDoubletap){	  this.doubletapEnabled=enableDoubletap;	}
boolean isDoubletapEnabled(){	  return doubletapEnabled;	}
void onPageError(PageRenderingException ex){	  if (!callbacks.callOnPageError(ex.getPage(),ex.getCause())) {	    Log.e(TAG,"Cannot open page " + ex.getPage(),ex.getCause());	  }	}
public void recycle(){	  waitingDocumentConfigurator=null;	  animationManager.stopAll();	  dragPinchManager.disable();	  if (renderingHandler != null) {	    renderingHandler.stop();	    renderingHandler.removeMessages(RenderingHandler.MSG_RENDER_TASK);	  }	  if (decodingAsyncTask != null) {	    decodingAsyncTask.cancel(true);	  }	  cacheManager.recycle();	  if (scrollHandle != null && isScrollHandleInit) {	    scrollHandle.destroyLayout();	  }	  if (pdfFile != null) {	    pdfFile.dispose();	    pdfFile=null;	  }	  renderingHandler=null;	  scrollHandle=null;	  isScrollHandleInit=false;	  currentXOffset=currentYOffset=0;	  zoom=1f;	  recycled=true;	  callbacks=new Callbacks();	  state=State.DEFAULT;	}
public boolean isRecycled(){	  return recycled;	}
@Override public void computeScroll(){	  super.computeScroll();	  if (isInEditMode()) {	    return;	  }	  animationManager.computeFling();	}
@Override protected void onDetachedFromWindow(){	  recycle();	  super.onDetachedFromWindow();	}
@Override protected void onSizeChanged(int w,int h,int oldw,int oldh){	  hasSize=true;	  if (waitingDocumentConfigurator != null) {	    waitingDocumentConfigurator.load();	  }	  if (isInEditMode() || state != State.SHOWN) {	    return;	  }	  animationManager.stopAll();	  pdfFile.recalculatePageSizes(new Size(w,h));	  if (swipeVertical) {	    moveTo(currentXOffset,-pdfFile.getPageOffset(currentPage,zoom));	  }	 else {	    moveTo(-pdfFile.getPageOffset(currentPage,zoom),currentYOffset);	  }	  loadPageByOffset();	}
@Override public boolean canScrollHorizontally(int direction){	  if (pdfFile == null) {	    return true;	  }	  if (swipeVertical) {	    if (direction < 0 && currentXOffset < 0) {	      return true;	    }	 else     if (direction > 0 && currentXOffset + toCurrentScale(pdfFile.getMaxPageWidth()) > getWidth()) {	      return true;	    }	  }	 else {	    if (direction < 0 && currentXOffset < 0) {	      return true;	    }	 else     if (direction > 0 && currentXOffset + pdfFile.getDocLen(zoom) > getWidth()) {	      return true;	    }	  }	  return false;	}
@Override public boolean canScrollVertically(int direction){	  if (pdfFile == null) {	    return true;	  }	  if (swipeVertical) {	    if (direction < 0 && currentYOffset < 0) {	      return true;	    }	 else     if (direction > 0 && currentYOffset + pdfFile.getDocLen(zoom) > getHeight()) {	      return true;	    }	  }	 else {	    if (direction < 0 && currentYOffset < 0) {	      return true;	    }	 else     if (direction > 0 && currentYOffset + toCurrentScale(pdfFile.getMaxPageHeight()) > getHeight()) {	      return true;	    }	  }	  return false;	}
@Override protected void onDraw(Canvas canvas){	  if (isInEditMode()) {	    return;	  }	  if (enableAntialiasing) {	    canvas.setDrawFilter(antialiasFilter);	  }	  Drawable bg=getBackground();	  if (bg == null) {	    canvas.drawColor(nightMode ? Color.BLACK : Color.WHITE);	  }	 else {	    bg.draw(canvas);	  }	  if (recycled) {	    return;	  }	  if (state != State.SHOWN) {	    return;	  }	  float currentXOffset=this.currentXOffset;	  float currentYOffset=this.currentYOffset;	  canvas.translate(currentXOffset,currentYOffset);	  for (  PagePart part : cacheManager.getThumbnails()) {	    drawPart(canvas,part);	  }	  for (  PagePart part : cacheManager.getPageParts()) {	    drawPart(canvas,part);	    if (callbacks.getOnDrawAll() != null && !onDrawPagesNums.contains(part.getPage())) {	      onDrawPagesNums.add(part.getPage());	    }	  }	  for (  Integer page : onDrawPagesNums) {	    drawWithListener(canvas,page,callbacks.getOnDrawAll());	  }	  onDrawPagesNums.clear();	  drawWithListener(canvas,currentPage,callbacks.getOnDraw());	  canvas.translate(-currentXOffset,-currentYOffset);	}
private void drawWithListener(Canvas canvas,int page,OnDrawListener listener){	  if (listener != null) {	    float translateX, translateY;	    if (swipeVertical) {	      translateX=0;	      translateY=pdfFile.getPageOffset(page,zoom);	    }	 else {	      translateY=0;	      translateX=pdfFile.getPageOffset(page,zoom);	    }	    canvas.translate(translateX,translateY);	    SizeF size=pdfFile.getPageSize(page);	    listener.onLayerDrawn(canvas,toCurrentScale(size.getWidth()),toCurrentScale(size.getHeight()),page);	    canvas.translate(-translateX,-translateY);	  }	}
private void drawPart(Canvas canvas,PagePart part){	  RectF pageRelativeBounds=part.getPageRelativeBounds();	  Bitmap renderedBitmap=part.getRenderedBitmap();	  if (renderedBitmap.isRecycled()) {	    return;	  }	  float localTranslationX=0;	  float localTranslationY=0;	  SizeF size=pdfFile.getPageSize(part.getPage());	  if (swipeVertical) {	    localTranslationY=pdfFile.getPageOffset(part.getPage(),zoom);	    float maxWidth=pdfFile.getMaxPageWidth();	    localTranslationX=toCurrentScale(maxWidth - size.getWidth()) / 2;	  }	 else {	    localTranslationX=pdfFile.getPageOffset(part.getPage(),zoom);	    float maxHeight=pdfFile.getMaxPageHeight();	    localTranslationY=toCurrentScale(maxHeight - size.getHeight()) / 2;	  }	  canvas.translate(localTranslationX,localTranslationY);	  Rect srcRect=new Rect(0,0,renderedBitmap.getWidth(),renderedBitmap.getHeight());	  float offsetX=toCurrentScale(pageRelativeBounds.left * size.getWidth());	  float offsetY=toCurrentScale(pageRelativeBounds.top * size.getHeight());	  float width=toCurrentScale(pageRelativeBounds.width() * size.getWidth());	  float height=toCurrentScale(pageRelativeBounds.height() * size.getHeight());	  RectF dstRect=new RectF((int)offsetX,(int)offsetY,(int)(offsetX + width),(int)(offsetY + height));	  float translationX=currentXOffset + localTranslationX;	  float translationY=currentYOffset + localTranslationY;	  if (translationX + dstRect.left >= getWidth() || translationX + dstRect.right <= 0 || translationY + dstRect.top >= getHeight() || translationY + dstRect.bottom <= 0) {	    canvas.translate(-localTranslationX,-localTranslationY);	    return;	  }	  canvas.drawBitmap(renderedBitmap,srcRect,dstRect,paint);	  if (Constants.DEBUG_MODE) {	    debugPaint.setColor(part.getPage() % 2 == 0 ? Color.RED : Color.BLUE);	    canvas.drawRect(dstRect,debugPaint);	  }	  canvas.translate(-localTranslationX,-localTranslationY);	}
public void loadPages(){	  if (pdfFile == null || renderingHandler == null) {	    return;	  }	  renderingHandler.removeMessages(RenderingHandler.MSG_RENDER_TASK);	  cacheManager.makeANewSet();	  pagesLoader.loadPages();	  redraw();	}
void loadComplete(PdfFile pdfFile){	  state=State.LOADED;	  this.pdfFile=pdfFile;	  if (!renderingHandlerThread.isAlive()) {	    renderingHandlerThread.start();	  }	  renderingHandler=new RenderingHandler(renderingHandlerThread.getLooper(),this);	  renderingHandler.start();	  if (scrollHandle != null) {	    scrollHandle.setupLayout(this);	    isScrollHandleInit=true;	  }	  dragPinchManager.enable();	  callbacks.callOnLoadComplete(pdfFile.getPagesCount());	  jumpTo(defaultPage,false);	}
void loadError(Throwable t){	  state=State.ERROR;	  OnErrorListener onErrorListener=callbacks.getOnError();	  recycle();	  invalidate();	  if (onErrorListener != null) {	    onErrorListener.onError(t);	  }	 else {	    Log.e("PDFView","load pdf error",t);	  }	}
void redraw(){	  invalidate();	}
public void onBitmapRendered(PagePart part){	  if (state == State.LOADED) {	    state=State.SHOWN;	    callbacks.callOnRender(pdfFile.getPagesCount());	  }	  if (part.isThumbnail()) {	    cacheManager.cacheThumbnail(part);	  }	 else {	    cacheManager.cachePart(part);	  }	  redraw();	}
public void moveTo(float offsetX,float offsetY){	  moveTo(offsetX,offsetY,true);	}
public void moveTo(float offsetX,float offsetY,boolean moveHandle){	  if (swipeVertical) {	    float scaledPageWidth=toCurrentScale(pdfFile.getMaxPageWidth());	    if (scaledPageWidth < getWidth()) {	      offsetX=getWidth() / 2 - scaledPageWidth / 2;	    }	 else {	      if (offsetX > 0) {	        offsetX=0;	      }	 else       if (offsetX + scaledPageWidth < getWidth()) {	        offsetX=getWidth() - scaledPageWidth;	      }	    }	    float contentHeight=pdfFile.getDocLen(zoom);	    if (contentHeight < getHeight()) {	      offsetY=(getHeight() - contentHeight) / 2;	    }	 else {	      if (offsetY > 0) {	        offsetY=0;	      }	 else       if (offsetY + contentHeight < getHeight()) {	        offsetY=-contentHeight + getHeight();	      }	    }	    if (offsetY < currentYOffset) {	      scrollDir=ScrollDir.END;	    }	 else     if (offsetY > currentYOffset) {	      scrollDir=ScrollDir.START;	    }	 else {	      scrollDir=ScrollDir.NONE;	    }	  }	 else {	    float scaledPageHeight=toCurrentScale(pdfFile.getMaxPageHeight());	    if (scaledPageHeight < getHeight()) {	      offsetY=getHeight() / 2 - scaledPageHeight / 2;	    }	 else {	      if (offsetY > 0) {	        offsetY=0;	      }	 else       if (offsetY + scaledPageHeight < getHeight()) {	        offsetY=getHeight() - scaledPageHeight;	      }	    }	    float contentWidth=pdfFile.getDocLen(zoom);	    if (contentWidth < getWidth()) {	      offsetX=(getWidth() - contentWidth) / 2;	    }	 else {	      if (offsetX > 0) {	        offsetX=0;	      }	 else       if (offsetX + contentWidth < getWidth()) {	        offsetX=-contentWidth + getWidth();	      }	    }	    if (offsetX < currentXOffset) {	      scrollDir=ScrollDir.END;	    }	 else     if (offsetX > currentXOffset) {	      scrollDir=ScrollDir.START;	    }	 else {	      scrollDir=ScrollDir.NONE;	    }	  }	  currentXOffset=offsetX;	  currentYOffset=offsetY;	  float positionOffset=getPositionOffset();	  if (moveHandle && scrollHandle != null && !documentFitsView()) {	    scrollHandle.setScroll(positionOffset);	  }	  callbacks.callOnPageScroll(getCurrentPage(),positionOffset);	  redraw();	}
void loadPageByOffset(){	  if (0 == pdfFile.getPagesCount()) {	    return;	  }	  float offset, screenCenter;	  if (swipeVertical) {	    offset=currentYOffset;	    screenCenter=((float)getHeight()) / 2;	  }	 else {	    offset=currentXOffset;	    screenCenter=((float)getWidth()) / 2;	  }	  int page=pdfFile.getPageAtOffset(-(offset - screenCenter),zoom);	  if (page >= 0 && page <= pdfFile.getPagesCount() - 1 && page != getCurrentPage()) {	    showPage(page);	  }	 else {	    loadPages();	  }	}
public void performPageSnap(){	  if (!pageSnap || pdfFile == null || pdfFile.getPagesCount() == 0) {	    return;	  }	  int centerPage=findFocusPage(currentXOffset,currentYOffset);	  SnapEdge edge=findSnapEdge(centerPage);	  if (edge == SnapEdge.NONE) {	    return;	  }	  float offset=snapOffsetForPage(centerPage,edge);	  if (swipeVertical) {	    animationManager.startYAnimation(currentYOffset,-offset);	  }	 else {	    animationManager.startXAnimation(currentXOffset,-offset);	  }	}
SnapEdge findSnapEdge(int page){	  if (!pageSnap || page < 0) {	    return SnapEdge.NONE;	  }	  float currentOffset=swipeVertical ? currentYOffset : currentXOffset;	  float offset=-pdfFile.getPageOffset(page,zoom);	  int length=swipeVertical ? getHeight() : getWidth();	  float pageLength=pdfFile.getPageLength(page,zoom);	  if (length >= pageLength) {	    return SnapEdge.CENTER;	  }	 else   if (currentOffset >= offset) {	    return SnapEdge.START;	  }	 else   if (offset - pageLength > currentOffset - length) {	    return SnapEdge.END;	  }	 else {	    return SnapEdge.NONE;	  }	}
float snapOffsetForPage(int pageIndex,SnapEdge edge){	  float offset=pdfFile.getPageOffset(pageIndex,zoom);	  float length=swipeVertical ? getHeight() : getWidth();	  float pageLength=pdfFile.getPageLength(pageIndex,zoom);	  if (edge == SnapEdge.CENTER) {	    offset=offset - length / 2f + pageLength / 2f;	  }	 else   if (edge == SnapEdge.END) {	    offset=offset - length + pageLength;	  }	  return offset;	}
int findFocusPage(float xOffset,float yOffset){	  float currOffset=swipeVertical ? yOffset : xOffset;	  float length=swipeVertical ? getHeight() : getWidth();	  if (currOffset > -1) {	    return 0;	  }	 else   if (currOffset < -pdfFile.getDocLen(zoom) + length + 1) {	    return pdfFile.getPagesCount() - 1;	  }	  float center=currOffset - length / 2f;	  return pdfFile.getPageAtOffset(-center,zoom);	}
public boolean pageFillsScreen(){	  float start=-pdfFile.getPageOffset(currentPage,zoom);	  float end=start - pdfFile.getPageLength(currentPage,zoom);	  if (isSwipeVertical()) {	    return start > currentYOffset && end < currentYOffset - getHeight();	  }	 else {	    return start > currentXOffset && end < currentXOffset - getWidth();	  }	}
public void moveRelativeTo(float dx,float dy){	  moveTo(currentXOffset + dx,currentYOffset + dy);	}
public void zoomTo(float zoom){	  this.zoom=zoom;	}
public void zoomCenteredTo(float zoom,PointF pivot){	  float dzoom=zoom / this.zoom;	  zoomTo(zoom);	  float baseX=currentXOffset * dzoom;	  float baseY=currentYOffset * dzoom;	  baseX+=(pivot.x - pivot.x * dzoom);	  baseY+=(pivot.y - pivot.y * dzoom);	  moveTo(baseX,baseY);	}
public void zoomCenteredRelativeTo(float dzoom,PointF pivot){	  zoomCenteredTo(zoom * dzoom,pivot);	}
public boolean documentFitsView(){	  float len=pdfFile.getDocLen(1);	  if (swipeVertical) {	    return len < getHeight();	  }	 else {	    return len < getWidth();	  }	}
public void fitToWidth(int page){	  if (state != State.SHOWN) {	    Log.e(TAG,"Cannot fit, document not rendered yet");	    return;	  }	  zoomTo(getWidth() / pdfFile.getPageSize(page).getWidth());	  jumpTo(page);	}
public SizeF getPageSize(int pageIndex){	  if (pdfFile == null) {	    return new SizeF(0,0);	  }	  return pdfFile.getPageSize(pageIndex);	}
public int getCurrentPage(){	  return currentPage;	}
public float getCurrentXOffset(){	  return currentXOffset;	}
public float getCurrentYOffset(){	  return currentYOffset;	}
public float toRealScale(float size){	  return size / zoom;	}
public float toCurrentScale(float size){	  return size * zoom;	}
public float getZoom(){	  return zoom;	}
public boolean isZooming(){	  return zoom != minZoom;	}
private void setDefaultPage(int defaultPage){	  this.defaultPage=defaultPage;	}
public void resetZoom(){	  zoomTo(minZoom);	}
public void resetZoomWithAnimation(){	  zoomWithAnimation(minZoom);	}
public void zoomWithAnimation(float centerX,float centerY,float scale){	  animationManager.startZoomAnimation(centerX,centerY,zoom,scale);	}
public void zoomWithAnimation(float scale){	  animationManager.startZoomAnimation(getWidth() / 2,getHeight() / 2,zoom,scale);	}
private void setScrollHandle(ScrollHandle scrollHandle){	  this.scrollHandle=scrollHandle;	}
public int getPageAtPositionOffset(float positionOffset){	  return pdfFile.getPageAtOffset(pdfFile.getDocLen(zoom) * positionOffset,zoom);	}
public float getMinZoom(){	  return minZoom;	}
public void setMinZoom(float minZoom){	  this.minZoom=minZoom;	}
public float getMidZoom(){	  return midZoom;	}
public void setMidZoom(float midZoom){	  this.midZoom=midZoom;	}
public float getMaxZoom(){	  return maxZoom;	}
public void setMaxZoom(float maxZoom){	  this.maxZoom=maxZoom;	}
public void useBestQuality(boolean bestQuality){	  this.bestQuality=bestQuality;	}
public boolean isBestQuality(){	  return bestQuality;	}
public boolean isSwipeVertical(){	  return swipeVertical;	}
public boolean isSwipeEnabled(){	  return enableSwipe;	}
private void setSwipeVertical(boolean swipeVertical){	  this.swipeVertical=swipeVertical;	}
public void enableAnnotationRendering(boolean annotationRendering){	  this.annotationRendering=annotationRendering;	}
public boolean isAnnotationRendering(){	  return annotationRendering;	}
public void enableRenderDuringScale(boolean renderDuringScale){	  this.renderDuringScale=renderDuringScale;	}
public boolean isAntialiasing(){	  return enableAntialiasing;	}
public void enableAntialiasing(boolean enableAntialiasing){	  this.enableAntialiasing=enableAntialiasing;	}
public int getSpacingPx(){	  return spacingPx;	}
public boolean doAutoSpacing(){	  return autoSpacing;	}
public void setPageFling(boolean pageFling){	  this.pageFling=pageFling;	}
public boolean doPageFling(){	  return pageFling;	}
private void setSpacing(int spacing){	  this.spacingPx=Util.getDP(getContext(),spacing);	}
private void setAutoSpacing(boolean autoSpacing){	  this.autoSpacing=autoSpacing;	}
private void setPageFitPolicy(FitPolicy pageFitPolicy){	  this.pageFitPolicy=pageFitPolicy;	}
public FitPolicy getPageFitPolicy(){	  return pageFitPolicy;	}
public boolean doPageSnap(){	  return pageSnap;	}
public void setPageSnap(boolean pageSnap){	  this.pageSnap=pageSnap;	}
public boolean doRenderDuringScale(){	  return renderDuringScale;	}
public PdfDocument.Meta getDocumentMeta(){	  if (pdfFile == null) {	    return null;	  }	  return pdfFile.getMetaData();	}
public List<PdfDocument.Bookmark> getTableOfContents(){	  if (pdfFile == null) {	    return Collections.emptyList();	  }	  return pdfFile.getBookmarks();	}
public List<PdfDocument.Link> getLinks(int page){	  if (pdfFile == null) {	    return Collections.emptyList();	  }	  return pdfFile.getPageLinks(page);	}
public Configurator fromAsset(String assetName){	  return new Configurator(new AssetSource(assetName));	}
public Configurator fromFile(File file){	  return new Configurator(new FileSource(file));	}
public Configurator fromUri(Uri uri){	  return new Configurator(new UriSource(uri));	}
public Configurator fromBytes(byte[] bytes){	  return new Configurator(new ByteArraySource(bytes));	}
public Configurator fromStream(InputStream stream){	  return new Configurator(new InputStreamSource(stream));	}
public Configurator fromSource(DocumentSource docSource){	  return new Configurator(docSource);	}
RenderingHandler(Looper looper,PDFView pdfView){	  super(looper);	  this.pdfView=pdfView;	}
void addRenderingTask(int page,float width,float height,RectF bounds,boolean thumbnail,int cacheOrder,boolean bestQuality,boolean annotationRendering){	  RenderingTask task=new RenderingTask(width,height,bounds,page,thumbnail,cacheOrder,bestQuality,annotationRendering);	  Message msg=obtainMessage(MSG_RENDER_TASK,task);	  sendMessage(msg);	}
@Override public void handleMessage(Message message){	  RenderingTask task=(RenderingTask)message.obj;	  try {	    final PagePart part=proceed(task);	    if (part != null) {	      if (running) {	        pdfView.post(new Runnable(){	          @Override public void run(){	            pdfView.onBitmapRendered(part);	          }	        }	);	      }	 else {	        part.getRenderedBitmap().recycle();	      }	    }	  }	 catch (  final PageRenderingException ex) {	    pdfView.post(new Runnable(){	      @Override public void run(){	        pdfView.onPageError(ex);	      }	    }	);	  }	}
@Override public void run(){	  pdfView.onBitmapRendered(part);	}
@Override public void run(){	  pdfView.onPageError(ex);	}
private PagePart proceed(RenderingTask renderingTask) throws PageRenderingException {	  PdfFile pdfFile=pdfView.pdfFile;	  pdfFile.openPage(renderingTask.page);	  int w=Math.round(renderingTask.width);	  int h=Math.round(renderingTask.height);	  if (w == 0 || h == 0 || pdfFile.pageHasError(renderingTask.page)) {	    return null;	  }	  Bitmap render;	  try {	    render=Bitmap.createBitmap(w,h,renderingTask.bestQuality ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565);	  }	 catch (  IllegalArgumentException e) {	    Log.e(TAG,"Cannot create bitmap",e);	    return null;	  }	  calculateBounds(w,h,renderingTask.bounds);	  pdfFile.renderPageBitmap(render,renderingTask.page,roundedRenderBounds,renderingTask.annotationRendering);	  return new PagePart(renderingTask.page,render,renderingTask.bounds,renderingTask.thumbnail,renderingTask.cacheOrder);	}
private void calculateBounds(int width,int height,RectF pageSliceBounds){	  renderMatrix.reset();	  renderMatrix.postTranslate(-pageSliceBounds.left * width,-pageSliceBounds.top * height);	  renderMatrix.postScale(1 / pageSliceBounds.width(),1 / pageSliceBounds.height());	  renderBounds.set(0,0,width,height);	  renderMatrix.mapRect(renderBounds);	  renderBounds.round(roundedRenderBounds);	}
void stop(){	  running=false;	}
void start(){	  running=true;	}
boolean onTap(MotionEvent e);
void onLongPress(MotionEvent e);
public void setOnLoadComplete(OnLoadCompleteListener onLoadCompleteListener){	  this.onLoadCompleteListener=onLoadCompleteListener;	}
public void callOnLoadComplete(int pagesCount){	  if (onLoadCompleteListener != null) {	    onLoadCompleteListener.loadComplete(pagesCount);	  }	}
public void setOnError(OnErrorListener onErrorListener){	  this.onErrorListener=onErrorListener;	}
public OnErrorListener getOnError(){	  return onErrorListener;	}
public void setOnPageError(OnPageErrorListener onPageErrorListener){	  this.onPageErrorListener=onPageErrorListener;	}
public boolean callOnPageError(int page,Throwable error){	  if (onPageErrorListener != null) {	    onPageErrorListener.onPageError(page,error);	    return true;	  }	  return false;	}
public void setOnRender(OnRenderListener onRenderListener){	  this.onRenderListener=onRenderListener;	}
public void callOnRender(int pagesCount){	  if (onRenderListener != null) {	    onRenderListener.onInitiallyRendered(pagesCount);	  }	}
public void setOnPageChange(OnPageChangeListener onPageChangeListener){	  this.onPageChangeListener=onPageChangeListener;	}
public void callOnPageChange(int page,int pagesCount){	  if (onPageChangeListener != null) {	    onPageChangeListener.onPageChanged(page,pagesCount);	  }	}
public void setOnPageScroll(OnPageScrollListener onPageScrollListener){	  this.onPageScrollListener=onPageScrollListener;	}
public void callOnPageScroll(int currentPage,float offset){	  if (onPageScrollListener != null) {	    onPageScrollListener.onPageScrolled(currentPage,offset);	  }	}
public void setOnDraw(OnDrawListener onDrawListener){	  this.onDrawListener=onDrawListener;	}
public OnDrawListener getOnDraw(){	  return onDrawListener;	}
public void setOnDrawAll(OnDrawListener onDrawAllListener){	  this.onDrawAllListener=onDrawAllListener;	}
public OnDrawListener getOnDrawAll(){	  return onDrawAllListener;	}
public void setOnTap(OnTapListener onTapListener){	  this.onTapListener=onTapListener;	}
public boolean callOnTap(MotionEvent event){	  return onTapListener != null && onTapListener.onTap(event);	}
public void setOnLongPress(OnLongPressListener onLongPressListener){	  this.onLongPressListener=onLongPressListener;	}
public void callOnLongPress(MotionEvent event){	  if (onLongPressListener != null) {	    onLongPressListener.onLongPress(event);	  }	}
public void setLinkHandler(LinkHandler linkHandler){	  this.linkHandler=linkHandler;	}
public void callLinkHandler(LinkTapEvent event){	  if (linkHandler != null) {	    linkHandler.handleLinkEvent(event);	  }	}
void onError(Throwable t);
void onPageError(int page,Throwable t);
void onPageChanged(int page,int pageCount);
void onPageScrolled(int page,float positionOffset);
void onInitiallyRendered(int nbPages);
void loadComplete(int nbPages);
void onLayerDrawn(Canvas canvas,float pageWidth,float pageHeight,int displayedPage);
public InputStreamSource(InputStream inputStream){	  this.inputStream=inputStream;	}
@Override public PdfDocument createDocument(Context context,PdfiumCore core,String password) throws IOException {	  return core.newDocument(Util.toByteArray(inputStream),password);	}
public UriSource(Uri uri){	  this.uri=uri;	}
@Override public PdfDocument createDocument(Context context,PdfiumCore core,String password) throws IOException {	  ParcelFileDescriptor pfd=context.getContentResolver().openFileDescriptor(uri,"r");	  return core.newDocument(pfd,password);	}
public FileSource(File file){	  this.file=file;	}
@Override public PdfDocument createDocument(Context context,PdfiumCore core,String password) throws IOException {	  ParcelFileDescriptor pfd=ParcelFileDescriptor.open(file,ParcelFileDescriptor.MODE_READ_ONLY);	  return core.newDocument(pfd,password);	}
public ByteArraySource(byte[] data){	  this.data=data;	}
@Override public PdfDocument createDocument(Context context,PdfiumCore core,String password) throws IOException {	  return core.newDocument(data,password);	}
PdfDocument createDocument(Context context,PdfiumCore core,String password) throws IOException ;
public AssetSource(String assetName){	  this.assetName=assetName;	}
@Override public PdfDocument createDocument(Context context,PdfiumCore core,String password) throws IOException {	  File f=FileUtils.fileFromAsset(context,assetName);	  ParcelFileDescriptor pfd=ParcelFileDescriptor.open(f,ParcelFileDescriptor.MODE_READ_ONLY);	  return core.newDocument(pfd,password);	}
public PagePart(int page,Bitmap renderedBitmap,RectF pageRelativeBounds,boolean thumbnail,int cacheOrder){	  super();	  this.page=page;	  this.renderedBitmap=renderedBitmap;	  this.pageRelativeBounds=pageRelativeBounds;	  this.thumbnail=thumbnail;	  this.cacheOrder=cacheOrder;	}
public int getCacheOrder(){	  return cacheOrder;	}
public int getPage(){	  return page;	}
public Bitmap getRenderedBitmap(){	  return renderedBitmap;	}
public RectF getPageRelativeBounds(){	  return pageRelativeBounds;	}
public boolean isThumbnail(){	  return thumbnail;	}
public void setCacheOrder(int cacheOrder){	  this.cacheOrder=cacheOrder;	}
@Override public boolean equals(Object obj){	  if (!(obj instanceof PagePart)) {	    return false;	  }	  PagePart part=(PagePart)obj;	  return part.getPage() == page && part.getPageRelativeBounds().left == pageRelativeBounds.left && part.getPageRelativeBounds().right == pageRelativeBounds.right && part.getPageRelativeBounds().top == pageRelativeBounds.top && part.getPageRelativeBounds().bottom == pageRelativeBounds.bottom;	}
public LinkTapEvent(float originalX,float originalY,float documentX,float documentY,RectF mappedLinkRect,PdfDocument.Link link){	  this.originalX=originalX;	  this.originalY=originalY;	  this.documentX=documentX;	  this.documentY=documentY;	  this.mappedLinkRect=mappedLinkRect;	  this.link=link;	}
public float getOriginalX(){	  return originalX;	}
public float getOriginalY(){	  return originalY;	}
public float getDocumentX(){	  return documentX;	}
public float getDocumentY(){	  return documentY;	}
public RectF getMappedLinkRect(){	  return mappedLinkRect;	}
public PdfDocument.Link getLink(){	  return link;	}
void setScroll(float position);
void setupLayout(PDFView pdfView);
void destroyLayout();
void setPageNum(int pageNum);
boolean shown();
void show();
void hide();
void hideDelayed();
@Override public void run(){	  hide();	}
public DefaultScrollHandle(Context context){	  this(context,false);	}
public DefaultScrollHandle(Context context,boolean inverted){	  super(context);	  this.context=context;	  this.inverted=inverted;	  textView=new TextView(context);	  setVisibility(INVISIBLE);	  setTextColor(Color.BLACK);	  setTextSize(DEFAULT_TEXT_SIZE);	}
@Override public void setupLayout(PDFView pdfView){	  int align, width, height;	  Drawable background;	  if (pdfView.isSwipeVertical()) {	    width=HANDLE_LONG;	    height=HANDLE_SHORT;	    if (inverted) {	      align=ALIGN_PARENT_LEFT;	      background=ContextCompat.getDrawable(context,R.drawable.default_scroll_handle_left);	    }	 else {	      align=ALIGN_PARENT_RIGHT;	      background=ContextCompat.getDrawable(context,R.drawable.default_scroll_handle_right);	    }	  }	 else {	    width=HANDLE_SHORT;	    height=HANDLE_LONG;	    if (inverted) {	      align=ALIGN_PARENT_TOP;	      background=ContextCompat.getDrawable(context,R.drawable.default_scroll_handle_top);	    }	 else {	      align=ALIGN_PARENT_BOTTOM;	      background=ContextCompat.getDrawable(context,R.drawable.default_scroll_handle_bottom);	    }	  }	  if (android.os.Build.VERSION.SDK_INT < android.os.Build.VERSION_CODES.JELLY_BEAN) {	    setBackgroundDrawable(background);	  }	 else {	    setBackground(background);	  }	  LayoutParams lp=new LayoutParams(Util.getDP(context,width),Util.getDP(context,height));	  lp.setMargins(0,0,0,0);	  LayoutParams tvlp=new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);	  tvlp.addRule(RelativeLayout.CENTER_IN_PARENT,RelativeLayout.TRUE);	  addView(textView,tvlp);	  lp.addRule(align);	  pdfView.addView(this,lp);	  this.pdfView=pdfView;	}
@Override public void destroyLayout(){	  pdfView.removeView(this);	}
@Override public void setScroll(float position){	  if (!shown()) {	    show();	  }	 else {	    handler.removeCallbacks(hidePageScrollerRunnable);	  }	  setPosition((pdfView.isSwipeVertical() ? pdfView.getHeight() : pdfView.getWidth()) * position);	}
private void setPosition(float pos){	  if (Float.isInfinite(pos) || Float.isNaN(pos)) {	    return;	  }	  float pdfViewSize;	  if (pdfView.isSwipeVertical()) {	    pdfViewSize=pdfView.getHeight();	  }	 else {	    pdfViewSize=pdfView.getWidth();	  }	  pos-=relativeHandlerMiddle;	  if (pos < 0) {	    pos=0;	  }	 else   if (pos > pdfViewSize - Util.getDP(context,HANDLE_SHORT)) {	    pos=pdfViewSize - Util.getDP(context,HANDLE_SHORT);	  }	  if (pdfView.isSwipeVertical()) {	    setY(pos);	  }	 else {	    setX(pos);	  }	  calculateMiddle();	  invalidate();	}
private void calculateMiddle(){	  float pos, viewSize, pdfViewSize;	  if (pdfView.isSwipeVertical()) {	    pos=getY();	    viewSize=getHeight();	    pdfViewSize=pdfView.getHeight();	  }	 else {	    pos=getX();	    viewSize=getWidth();	    pdfViewSize=pdfView.getWidth();	  }	  relativeHandlerMiddle=((pos + relativeHandlerMiddle) / pdfViewSize) * viewSize;	}
@Override public void hideDelayed(){	  handler.postDelayed(hidePageScrollerRunnable,1000);	}
@Override public void setPageNum(int pageNum){	  String text=String.valueOf(pageNum);	  if (!textView.getText().equals(text)) {	    textView.setText(text);	  }	}
@Override public boolean shown(){	  return getVisibility() == VISIBLE;	}
@Override public void show(){	  setVisibility(VISIBLE);	}
@Override public void hide(){	  setVisibility(INVISIBLE);	}
public void setTextColor(int color){	  textView.setTextColor(color);	}
public void setTextSize(int size){	  textView.setTextSize(TypedValue.COMPLEX_UNIT_DIP,size);	}
private boolean isPDFViewReady(){	  return pdfView != null && pdfView.getPageCount() > 0 && !pdfView.documentFitsView();	}
@Override public boolean onTouchEvent(MotionEvent event){	  if (!isPDFViewReady()) {	    return super.onTouchEvent(event);	  }	switch (event.getAction()) {	case MotionEvent.ACTION_DOWN:	case MotionEvent.ACTION_POINTER_DOWN:	    pdfView.stopFling();	  handler.removeCallbacks(hidePageScrollerRunnable);	if (pdfView.isSwipeVertical()) {	  currentPos=event.getRawY() - getY();	}	 else {	  currentPos=event.getRawX() - getX();	}	case MotionEvent.ACTION_MOVE:	if (pdfView.isSwipeVertical()) {	setPosition(event.getRawY() - currentPos + relativeHandlerMiddle);	pdfView.setPositionOffset(relativeHandlerMiddle / (float)getHeight(),false);	}	 else {	setPosition(event.getRawX() - currentPos + relativeHandlerMiddle);	pdfView.setPositionOffset(relativeHandlerMiddle / (float)getWidth(),false);	}	return true;	case MotionEvent.ACTION_CANCEL:	case MotionEvent.ACTION_UP:	case MotionEvent.ACTION_POINTER_UP:	hideDelayed();	pdfView.performPageSnap();	return true;	}	return super.onTouchEvent(event);	}
void handleLinkEvent(LinkTapEvent event);
public DefaultLinkHandler(PDFView pdfView){	  this.pdfView=pdfView;	}
@Override public void handleLinkEvent(LinkTapEvent event){	  String uri=event.getLink().getUri();	  Integer page=event.getLink().getDestPageIdx();	  if (uri != null && !uri.isEmpty()) {	    handleUri(uri);	  }	 else   if (page != null) {	    handlePage(page);	  }	}
private void handleUri(String uri){	  Uri parsedUri=Uri.parse(uri);	  Intent intent=new Intent(Intent.ACTION_VIEW,parsedUri);	  Context context=pdfView.getContext();	  if (intent.resolveActivity(context.getPackageManager()) != null) {	    context.startActivity(intent);	  }	 else {	    Log.w(TAG,"No activity found for URI: " + uri);	  }	}
private void handlePage(int page){	  pdfView.jumpTo(page);	}
public PageRenderingException(int page,Throwable cause){	  super(cause);	  this.page=page;	}
public int getPage(){	  return page;	}
public FileNotFoundException(String detailMessage){	  super(detailMessage);	}
public FileNotFoundException(String detailMessage,Throwable throwable){	  super(detailMessage,throwable);	}
private void handleResult(final BleDevice bleDevice){	  mMainHandler.post(new Runnable(){	    @Override public void run(){	      onLeScan(bleDevice);	    }	  }	);	  checkDevice(bleDevice);	}
@Override public void run(){	  onLeScan(bleDevice);	}
public void prepare(String[] names,String mac,boolean fuzzy,boolean needConnect,long timeOut,BleScanPresenterImp bleScanPresenterImp){	  mDeviceNames=names;	  mDeviceMac=mac;	  mFuzzy=fuzzy;	  mNeedConnect=needConnect;	  mScanTimeout=timeOut;	  mBleScanPresenterImp=bleScanPresenterImp;	  mHandlerThread=new HandlerThread(BleScanPresenter.class.getSimpleName());	  mHandlerThread.start();	  mHandler=new ScanHandler(mHandlerThread.getLooper(),this);	  mHandling=true;	}
public boolean ismNeedConnect(){	  return mNeedConnect;	}
public BleScanPresenterImp getBleScanPresenterImp(){	  return mBleScanPresenterImp;	}
@Override public void onLeScan(BluetoothDevice device,int rssi,byte[] scanRecord){	  if (device == null)   return;	  if (!mHandling)   return;	  Message message=mHandler.obtainMessage();	  message.what=BleMsg.MSG_SCAN_DEVICE;	  message.obj=new BleDevice(device,rssi,scanRecord,System.currentTimeMillis());	  mHandler.sendMessage(message);	}
private void checkDevice(BleDevice bleDevice){	  if (TextUtils.isEmpty(mDeviceMac) && (mDeviceNames == null || mDeviceNames.length < 1)) {	    correctDeviceAndNextStep(bleDevice);	    return;	  }	  if (!TextUtils.isEmpty(mDeviceMac)) {	    if (!mDeviceMac.equalsIgnoreCase(bleDevice.getMac()))     return;	  }	  if (mDeviceNames != null && mDeviceNames.length > 0) {	    AtomicBoolean equal=new AtomicBoolean(false);	    for (    String name : mDeviceNames) {	      String remoteName=bleDevice.getName();	      if (remoteName == null)       remoteName="";	      if (mFuzzy ? remoteName.contains(name) : remoteName.equals(name)) {	        equal.set(true);	      }	    }	    if (!equal.get()) {	      return;	    }	  }	  correctDeviceAndNextStep(bleDevice);	}
private void correctDeviceAndNextStep(final BleDevice bleDevice){	  if (mNeedConnect) {	    BleLog.i("devices detected  ------" + "  name:" + bleDevice.getName() + "  mac:"+ bleDevice.getMac()+ "  Rssi:"+ bleDevice.getRssi()+ "  scanRecord:"+ HexUtil.formatHexString(bleDevice.getScanRecord()));	    mBleDeviceList.add(bleDevice);	    mMainHandler.post(new Runnable(){	      @Override public void run(){	        BleScanner.getInstance().stopLeScan();	      }	    }	);	  }	 else {	    AtomicBoolean hasFound=new AtomicBoolean(false);	    for (    BleDevice result : mBleDeviceList) {	      if (result.getDevice().equals(bleDevice.getDevice())) {	        hasFound.set(true);	      }	    }	    if (!hasFound.get()) {	      BleLog.i("device detected  ------" + "  name: " + bleDevice.getName() + "  mac: "+ bleDevice.getMac()+ "  Rssi: "+ bleDevice.getRssi()+ "  scanRecord: "+ HexUtil.formatHexString(bleDevice.getScanRecord(),true));	      mBleDeviceList.add(bleDevice);	      mMainHandler.post(new Runnable(){	        @Override public void run(){	          onScanning(bleDevice);	        }	      }	);	    }	  }	}
@Override public void run(){	  BleScanner.getInstance().stopLeScan();	}
@Override public void run(){	  onScanning(bleDevice);	}
public final void notifyScanStarted(final boolean success){	  mBleDeviceList.clear();	  removeHandlerMsg();	  if (success && mScanTimeout > 0) {	    mMainHandler.postDelayed(new Runnable(){	      @Override public void run(){	        BleScanner.getInstance().stopLeScan();	      }	    }	,mScanTimeout);	  }	  mMainHandler.post(new Runnable(){	    @Override public void run(){	      onScanStarted(success);	    }	  }	);	}
@Override public void run(){	  BleScanner.getInstance().stopLeScan();	}
@Override public void run(){	  onScanStarted(success);	}
public final void notifyScanStopped(){	  mHandling=false;	  mHandlerThread.quit();	  removeHandlerMsg();	  mMainHandler.post(new Runnable(){	    @Override public void run(){	      onScanFinished(mBleDeviceList);	    }	  }	);	}
@Override public void run(){	  onScanFinished(mBleDeviceList);	}
public final void removeHandlerMsg(){	  mMainHandler.removeCallbacksAndMessages(null);	  mHandler.removeCallbacksAndMessages(null);	}
public abstract void onScanStarted(boolean success);
public abstract void onLeScan(BleDevice bleDevice);
public abstract void onScanning(BleDevice bleDevice);
public abstract void onScanFinished(List<BleDevice> bleDeviceList);
public UUID[] getServiceUuids(){	  return mServiceUuids;	}
public String[] getDeviceNames(){	  return mDeviceNames;	}
public String getDeviceMac(){	  return mDeviceMac;	}
public boolean isAutoConnect(){	  return mAutoConnect;	}
public boolean isFuzzy(){	  return mFuzzy;	}
public long getScanTimeOut(){	  return mScanTimeOut;	}
public static BleScanner getInstance(){	  return BleScannerHolder.sBleScanner;	}
@Override public void onScanStarted(boolean success){	  BleScanPresenterImp callback=mBleScanPresenter.getBleScanPresenterImp();	  if (callback != null) {	    callback.onScanStarted(success);	  }	}
@Override public void onLeScan(BleDevice bleDevice){	  if (mBleScanPresenter.ismNeedConnect()) {	    BleScanAndConnectCallback callback=(BleScanAndConnectCallback)mBleScanPresenter.getBleScanPresenterImp();	    if (callback != null) {	      callback.onLeScan(bleDevice);	    }	  }	 else {	    BleScanCallback callback=(BleScanCallback)mBleScanPresenter.getBleScanPresenterImp();	    if (callback != null) {	      callback.onLeScan(bleDevice);	    }	  }	}
@Override public void onScanning(BleDevice result){	  BleScanPresenterImp callback=mBleScanPresenter.getBleScanPresenterImp();	  if (callback != null) {	    callback.onScanning(result);	  }	}
@Override public void onScanFinished(List<BleDevice> bleDeviceList){	  if (mBleScanPresenter.ismNeedConnect()) {	    final BleScanAndConnectCallback callback=(BleScanAndConnectCallback)mBleScanPresenter.getBleScanPresenterImp();	    if (bleDeviceList == null || bleDeviceList.size() < 1) {	      if (callback != null) {	        callback.onScanFinished(null);	      }	    }	 else {	      if (callback != null) {	        callback.onScanFinished(bleDeviceList.get(0));	      }	      final List<BleDevice> list=bleDeviceList;	      new Handler(Looper.getMainLooper()).postDelayed(new Runnable(){	        @Override public void run(){	          BleManager.getInstance().connect(list.get(0),callback);	        }	      }	,100);	    }	  }	 else {	    BleScanCallback callback=(BleScanCallback)mBleScanPresenter.getBleScanPresenterImp();	    if (callback != null) {	      callback.onScanFinished(bleDeviceList);	    }	  }	}
@Override public void run(){	  BleManager.getInstance().connect(list.get(0),callback);	}
public void scan(UUID[] serviceUuids,String[] names,String mac,boolean fuzzy,long timeOut,final BleScanCallback callback){	  startLeScan(serviceUuids,names,mac,fuzzy,false,timeOut,callback);	}
public void scanAndConnect(UUID[] serviceUuids,String[] names,String mac,boolean fuzzy,long timeOut,BleScanAndConnectCallback callback){	  startLeScan(serviceUuids,names,mac,fuzzy,true,timeOut,callback);	}
private synchronized void startLeScan(UUID[] serviceUuids,String[] names,String mac,boolean fuzzy,boolean needConnect,long timeOut,BleScanPresenterImp imp){	  if (mBleScanState != BleScanState.STATE_IDLE) {	    BleLog.w("scan action already exists, complete the previous scan action first");	    if (imp != null) {	      imp.onScanStarted(false);	    }	    return;	  }	  mBleScanPresenter.prepare(names,mac,fuzzy,needConnect,timeOut,imp);	  boolean success=BleManager.getInstance().getBluetoothAdapter().startLeScan(serviceUuids,mBleScanPresenter);	  mBleScanState=success ? BleScanState.STATE_SCANNING : BleScanState.STATE_IDLE;	  mBleScanPresenter.notifyScanStarted(success);	}
public synchronized void stopLeScan(){	  BleManager.getInstance().getBluetoothAdapter().stopLeScan(mBleScanPresenter);	  mBleScanState=BleScanState.STATE_IDLE;	  mBleScanPresenter.notifyScanStopped();	}
public BleScanState getScanState(){	  return mBleScanState;	}
public abstract void onRssiFailure(BleException exception);
public abstract void onRssiSuccess(int rssi);
public abstract void onIndicateSuccess();
public abstract void onIndicateFailure(BleException exception);
public abstract void onCharacteristicChanged(byte[] data);
public abstract void onSetMTUFailure(BleException exception);
public abstract void onMtuChanged(int mtu);
public abstract void onScanFinished(List<BleDevice> scanResultList);
public void onLeScan(BleDevice bleDevice){	}
public abstract void onReadSuccess(byte[] data);
public abstract void onReadFailure(BleException exception);
void onScanStarted(boolean success);
void onScanning(BleDevice bleDevice);
public abstract void onWriteSuccess(int current,int total,byte[] justWrite);
public abstract void onWriteFailure(BleException exception);
public abstract void onNotifySuccess();
public abstract void onNotifyFailure(BleException exception);
public abstract void onCharacteristicChanged(byte[] data);
public abstract void onStartConnect();
public abstract void onConnectFail(BleDevice bleDevice,BleException exception);
public abstract void onConnectSuccess(BleDevice bleDevice,BluetoothGatt gatt,int status);
public abstract void onDisConnected(boolean isActiveDisConnected,BleDevice device,BluetoothGatt gatt,int status);
public abstract void onScanFinished(BleDevice scanResult);
public void onLeScan(BleDevice bleDevice){	}
public String getKey(){	  return key;	}
public void setKey(String key){	  this.key=key;	}
public Handler getHandler(){	  return handler;	}
public void setHandler(Handler handler){	  this.handler=handler;	}
public MultipleBluetoothController(){	  bleLruHashMap=new BleLruHashMap<>(BleManager.getInstance().getMaxConnectCount());	  bleTempHashMap=new HashMap<>();	}
public synchronized BleBluetooth buildConnectingBle(BleDevice bleDevice){	  BleBluetooth bleBluetooth=new BleBluetooth(bleDevice);	  if (!bleTempHashMap.containsKey(bleBluetooth.getDeviceKey())) {	    bleTempHashMap.put(bleBluetooth.getDeviceKey(),bleBluetooth);	  }	  return bleBluetooth;	}
public synchronized void removeConnectingBle(BleBluetooth bleBluetooth){	  if (bleBluetooth == null) {	    return;	  }	  if (bleTempHashMap.containsKey(bleBluetooth.getDeviceKey())) {	    bleTempHashMap.remove(bleBluetooth.getDeviceKey());	  }	}
public synchronized void addBleBluetooth(BleBluetooth bleBluetooth){	  if (bleBluetooth == null) {	    return;	  }	  if (!bleLruHashMap.containsKey(bleBluetooth.getDeviceKey())) {	    bleLruHashMap.put(bleBluetooth.getDeviceKey(),bleBluetooth);	  }	}
public synchronized void removeBleBluetooth(BleBluetooth bleBluetooth){	  if (bleBluetooth == null) {	    return;	  }	  if (bleLruHashMap.containsKey(bleBluetooth.getDeviceKey())) {	    bleLruHashMap.remove(bleBluetooth.getDeviceKey());	  }	}
public synchronized boolean isContainDevice(BleDevice bleDevice){	  return bleDevice != null && bleLruHashMap.containsKey(bleDevice.getKey());	}
public synchronized boolean isContainDevice(BluetoothDevice bluetoothDevice){	  return bluetoothDevice != null && bleLruHashMap.containsKey(bluetoothDevice.getName() + bluetoothDevice.getAddress());	}
public synchronized BleBluetooth getBleBluetooth(BleDevice bleDevice){	  if (bleDevice != null) {	    if (bleLruHashMap.containsKey(bleDevice.getKey())) {	      return bleLruHashMap.get(bleDevice.getKey());	    }	  }	  return null;	}
public synchronized void disconnect(BleDevice bleDevice){	  if (isContainDevice(bleDevice)) {	    getBleBluetooth(bleDevice).disconnect();	  }	}
public synchronized void disconnectAllDevice(){	  for (  Map.Entry<String,BleBluetooth> stringBleBluetoothEntry : bleLruHashMap.entrySet()) {	    stringBleBluetoothEntry.getValue().disconnect();	  }	  bleLruHashMap.clear();	}
public synchronized void destroy(){	  for (  Map.Entry<String,BleBluetooth> stringBleBluetoothEntry : bleLruHashMap.entrySet()) {	    stringBleBluetoothEntry.getValue().destroy();	  }	  bleLruHashMap.clear();	  for (  Map.Entry<String,BleBluetooth> stringBleBluetoothEntry : bleTempHashMap.entrySet()) {	    stringBleBluetoothEntry.getValue().destroy();	  }	  bleTempHashMap.clear();	}
public synchronized List<BleBluetooth> getBleBluetoothList(){	  List<BleBluetooth> bleBluetoothList=new ArrayList<>(bleLruHashMap.values());	  Collections.sort(bleBluetoothList,new Comparator<BleBluetooth>(){	    @Override public int compare(    BleBluetooth lhs,    BleBluetooth rhs){	      return lhs.getDeviceKey().compareToIgnoreCase(rhs.getDeviceKey());	    }	  }	);	  return bleBluetoothList;	}
@Override public int compare(BleBluetooth lhs,BleBluetooth rhs){	  return lhs.getDeviceKey().compareToIgnoreCase(rhs.getDeviceKey());	}
public synchronized List<BleDevice> getDeviceList(){	  refreshConnectedDevice();	  List<BleDevice> deviceList=new ArrayList<>();	  for (  BleBluetooth BleBluetooth : getBleBluetoothList()) {	    if (BleBluetooth != null) {	      deviceList.add(BleBluetooth.getDevice());	    }	  }	  return deviceList;	}
public void refreshConnectedDevice(){	  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {	    List<BleBluetooth> bluetoothList=getBleBluetoothList();	    for (int i=0; bluetoothList != null && i < bluetoothList.size(); i++) {	      BleBluetooth bleBluetooth=bluetoothList.get(i);	      if (!BleManager.getInstance().isConnected(bleBluetooth.getDevice())) {	        removeBleBluetooth(bleBluetooth);	      }	    }	  }	}
public SplitWriter(){	  mHandlerThread=new HandlerThread("splitWriter");	  mHandlerThread.start();	  mHandler=new Handler(mHandlerThread.getLooper()){	    @Override public void handleMessage(    Message msg){	      super.handleMessage(msg);	      if (msg.what == BleMsg.MSG_SPLIT_WRITE) {	        write();	      }	    }	  }	;	}
@Override public void handleMessage(Message msg){	  super.handleMessage(msg);	  if (msg.what == BleMsg.MSG_SPLIT_WRITE) {	    write();	  }	}
public void splitWrite(BleBluetooth bleBluetooth,String uuid_service,String uuid_write,byte[] data,BleWriteCallback callback){	  mBleBluetooth=bleBluetooth;	  mUuid_service=uuid_service;	  mUuid_write=uuid_write;	  mData=data;	  mCount=BleManager.getInstance().getSplitWriteNum();	  mCallback=callback;	  splitWrite();	}
private void splitWrite(){	  if (mData == null) {	    throw new IllegalArgumentException("data is Null!");	  }	  if (mCount < 1) {	    throw new IllegalArgumentException("split count should higher than 0!");	  }	  mDataQueue=splitByte(mData,mCount);	  mTotalNum=mDataQueue.size();	  write();	}
private void write(){	  if (mDataQueue.peek() == null) {	    release();	  }	 else {	    byte[] data=mDataQueue.poll();	    mBleBluetooth.newBleConnector().withUUIDString(mUuid_service,mUuid_write).writeCharacteristic(data,new BleWriteCallback(){	      @Override public void onWriteSuccess(      int current,      int total,      byte[] justWrite){	        int position=mTotalNum - mDataQueue.size();	        if (mCallback != null) {	          mCallback.onWriteSuccess(position,mTotalNum,justWrite);	        }	        if (Looper.myLooper() != null && Looper.myLooper() == Looper.getMainLooper()) {	          write();	        }	 else {	          Message message=mHandler.obtainMessage(BleMsg.MSG_SPLIT_WRITE);	          mHandler.sendMessage(message);	        }	      }	      @Override public void onWriteFailure(      BleException exception){	        if (mCallback != null) {	          mCallback.onWriteFailure(new OtherException("exception occur while writing: " + exception.getDescription()));	        }	      }	    }	,mUuid_write);	  }	}
@Override public void onWriteSuccess(int current,int total,byte[] justWrite){	  int position=mTotalNum - mDataQueue.size();	  if (mCallback != null) {	    mCallback.onWriteSuccess(position,mTotalNum,justWrite);	  }	  if (Looper.myLooper() != null && Looper.myLooper() == Looper.getMainLooper()) {	    write();	  }	 else {	    Message message=mHandler.obtainMessage(BleMsg.MSG_SPLIT_WRITE);	    mHandler.sendMessage(message);	  }	}
@Override public void onWriteFailure(BleException exception){	  if (mCallback != null) {	    mCallback.onWriteFailure(new OtherException("exception occur while writing: " + exception.getDescription()));	  }	}
private void release(){	  mHandlerThread.quit();	  mHandler.removeCallbacksAndMessages(null);	}
private static Queue<byte[]> splitByte(byte[] data,int count){	  if (count > 20) {	    BleLog.w("Be careful: split count beyond 20! Ensure MTU higher than 23!");	  }	  Queue<byte[]> byteQueue=new LinkedList<>();	  if (data != null) {	    int index=0;	    do {	      byte[] rawData=new byte[data.length - index];	      byte[] newData;	      System.arraycopy(data,index,rawData,0,data.length - index);	      if (rawData.length <= count) {	        newData=new byte[rawData.length];	        System.arraycopy(rawData,0,newData,0,rawData.length);	        index+=rawData.length;	      }	 else {	        newData=new byte[count];	        System.arraycopy(data,index,newData,0,count);	        index+=count;	      }	      byteQueue.offer(newData);	    }	 while (index < data.length);	  }	  return byteQueue;	}
public BleBluetooth(BleDevice bleDevice){	  this.bleDevice=bleDevice;	}
public BleConnector newBleConnector(){	  return new BleConnector(this);	}
public synchronized void addConnectGattCallback(BleGattCallback callback){	  bleGattCallback=callback;	}
public synchronized void removeConnectGattCallback(){	  bleGattCallback=null;	}
public synchronized void addNotifyCallback(String uuid,BleNotifyCallback bleNotifyCallback){	  bleNotifyCallbackHashMap.put(uuid,bleNotifyCallback);	}
public synchronized void addIndicateCallback(String uuid,BleIndicateCallback bleIndicateCallback){	  bleIndicateCallbackHashMap.put(uuid,bleIndicateCallback);	}
public synchronized void addWriteCallback(String uuid,BleWriteCallback bleWriteCallback){	  bleWriteCallbackHashMap.put(uuid,bleWriteCallback);	}
public synchronized void addReadCallback(String uuid,BleReadCallback bleReadCallback){	  bleReadCallbackHashMap.put(uuid,bleReadCallback);	}
public synchronized void removeNotifyCallback(String uuid){	  if (bleNotifyCallbackHashMap.containsKey(uuid))   bleNotifyCallbackHashMap.remove(uuid);	}
public synchronized void removeIndicateCallback(String uuid){	  if (bleIndicateCallbackHashMap.containsKey(uuid))   bleIndicateCallbackHashMap.remove(uuid);	}
public synchronized void removeWriteCallback(String uuid){	  if (bleWriteCallbackHashMap.containsKey(uuid))   bleWriteCallbackHashMap.remove(uuid);	}
public synchronized void removeReadCallback(String uuid){	  if (bleReadCallbackHashMap.containsKey(uuid))   bleReadCallbackHashMap.remove(uuid);	}
public synchronized void clearCharacterCallback(){	  if (bleNotifyCallbackHashMap != null)   bleNotifyCallbackHashMap.clear();	  if (bleIndicateCallbackHashMap != null)   bleIndicateCallbackHashMap.clear();	  if (bleWriteCallbackHashMap != null)   bleWriteCallbackHashMap.clear();	  if (bleReadCallbackHashMap != null)   bleReadCallbackHashMap.clear();	}
public synchronized void addRssiCallback(BleRssiCallback callback){	  bleRssiCallback=callback;	}
public synchronized void removeRssiCallback(){	  bleRssiCallback=null;	}
public synchronized void addMtuChangedCallback(BleMtuChangedCallback callback){	  bleMtuChangedCallback=callback;	}
public synchronized void removeMtuChangedCallback(){	  bleMtuChangedCallback=null;	}
public String getDeviceKey(){	  return bleDevice.getKey();	}
public BleDevice getDevice(){	  return bleDevice;	}
public BluetoothGatt getBluetoothGatt(){	  return bluetoothGatt;	}
public synchronized BluetoothGatt connect(BleDevice bleDevice,boolean autoConnect,BleGattCallback callback){	  BleLog.i("connect device: " + bleDevice.getName() + "\nmac: "+ bleDevice.getMac()+ "\nautoConnect: "+ autoConnect+ "\ncurrentThread: "+ Thread.currentThread().getId());	  addConnectGattCallback(callback);	  lastState=LastState.CONNECT_CONNECTING;	  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {	    bluetoothGatt=bleDevice.getDevice().connectGatt(BleManager.getInstance().getContext(),autoConnect,coreGattCallback,TRANSPORT_LE);	  }	 else {	    bluetoothGatt=bleDevice.getDevice().connectGatt(BleManager.getInstance().getContext(),autoConnect,coreGattCallback);	  }	  if (bluetoothGatt != null) {	    if (bleGattCallback != null) {	      bleGattCallback.onStartConnect();	    }	    Message message=mainHandler.obtainMessage();	    message.what=BleMsg.MSG_CONNECT_OVER_TIME;	    mainHandler.sendMessageDelayed(message,BleManager.getInstance().getConnectOverTime());	  }	 else {	    disconnectGatt();	    refreshDeviceCache();	    closeBluetoothGatt();	    lastState=LastState.CONNECT_FAILURE;	    BleManager.getInstance().getMultipleBluetoothController().removeConnectingBle(BleBluetooth.this);	    if (bleGattCallback != null)     bleGattCallback.onConnectFail(bleDevice,new OtherException("GATT connect exception occurred!"));	  }	  return bluetoothGatt;	}
public synchronized void disconnect(){	  isActiveDisconnect=true;	  disconnectGatt();	}
public synchronized void destroy(){	  lastState=LastState.CONNECT_IDLE;	  disconnectGatt();	  refreshDeviceCache();	  closeBluetoothGatt();	  removeConnectGattCallback();	  removeRssiCallback();	  removeMtuChangedCallback();	  clearCharacterCallback();	  mainHandler.removeCallbacksAndMessages(null);	}
private synchronized void disconnectGatt(){	  if (bluetoothGatt != null) {	    bluetoothGatt.disconnect();	  }	}
private synchronized void refreshDeviceCache(){	  try {	    final Method refresh=BluetoothGatt.class.getMethod("refresh");	    if (refresh != null && bluetoothGatt != null) {	      boolean success=(Boolean)refresh.invoke(bluetoothGatt);	      BleLog.i("refreshDeviceCache, is success:  " + success);	    }	  }	 catch (  Exception e) {	    BleLog.i("exception occur while refreshing device: " + e.getMessage());	    e.printStackTrace();	  }	}
private synchronized void closeBluetoothGatt(){	  if (bluetoothGatt != null) {	    bluetoothGatt.close();	  }	}
BleConnector(BleBluetooth bleBluetooth){	  this.mBleBluetooth=bleBluetooth;	  this.mBluetoothGatt=bleBluetooth.getBluetoothGatt();	  this.mHandler=new Handler(Looper.getMainLooper()){	    @Override public void handleMessage(    Message msg){	      super.handleMessage(msg);	switch (msg.what) {	case BleMsg.MSG_CHA_NOTIFY_START:	{	          BleNotifyCallback notifyCallback=(BleNotifyCallback)msg.obj;	          if (notifyCallback != null)           notifyCallback.onNotifyFailure(new TimeoutException());	          break;	        }	case BleMsg.MSG_CHA_NOTIFY_RESULT:	{	        notifyMsgInit();	        BleNotifyCallback notifyCallback=(BleNotifyCallback)msg.obj;	        Bundle bundle=msg.getData();	        int status=bundle.getInt(BleMsg.KEY_NOTIFY_BUNDLE_STATUS);	        if (notifyCallback != null) {	          if (status == BluetoothGatt.GATT_SUCCESS) {	            notifyCallback.onNotifySuccess();	          }	 else {	            notifyCallback.onNotifyFailure(new GattException(status));	          }	        }	        break;	      }	case BleMsg.MSG_CHA_NOTIFY_DATA_CHANGE:	{	      BleNotifyCallback notifyCallback=(BleNotifyCallback)msg.obj;	      Bundle bundle=msg.getData();	      byte[] value=bundle.getByteArray(BleMsg.KEY_NOTIFY_BUNDLE_VALUE);	      if (notifyCallback != null) {	        notifyCallback.onCharacteristicChanged(value);	      }	      break;	    }	case BleMsg.MSG_CHA_INDICATE_START:	{	    BleIndicateCallback indicateCallback=(BleIndicateCallback)msg.obj;	    if (indicateCallback != null)     indicateCallback.onIndicateFailure(new TimeoutException());	    break;	  }	case BleMsg.MSG_CHA_INDICATE_RESULT:	{	  indicateMsgInit();	  BleIndicateCallback indicateCallback=(BleIndicateCallback)msg.obj;	  Bundle bundle=msg.getData();	  int status=bundle.getInt(BleMsg.KEY_INDICATE_BUNDLE_STATUS);	  if (indicateCallback != null) {	    if (status == BluetoothGatt.GATT_SUCCESS) {	      indicateCallback.onIndicateSuccess();	    }	 else {	      indicateCallback.onIndicateFailure(new GattException(status));	    }	  }	  break;	}	case BleMsg.MSG_CHA_INDICATE_DATA_CHANGE:	{	BleIndicateCallback indicateCallback=(BleIndicateCallback)msg.obj;	Bundle bundle=msg.getData();	byte[] value=bundle.getByteArray(BleMsg.KEY_INDICATE_BUNDLE_VALUE);	if (indicateCallback != null) {	  indicateCallback.onCharacteristicChanged(value);	}	break;	}	case BleMsg.MSG_CHA_WRITE_START:	{	BleWriteCallback writeCallback=(BleWriteCallback)msg.obj;	if (writeCallback != null) {	writeCallback.onWriteFailure(new TimeoutException());	}	break;	}	case BleMsg.MSG_CHA_WRITE_RESULT:	{	writeMsgInit();	BleWriteCallback writeCallback=(BleWriteCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_WRITE_BUNDLE_STATUS);	byte[] value=bundle.getByteArray(BleMsg.KEY_WRITE_BUNDLE_VALUE);	if (writeCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	writeCallback.onWriteSuccess(BleWriteState.DATA_WRITE_SINGLE,BleWriteState.DATA_WRITE_SINGLE,value);	}	 else {	writeCallback.onWriteFailure(new GattException(status));	}	}	break;	}	case BleMsg.MSG_CHA_READ_START:	{	BleReadCallback readCallback=(BleReadCallback)msg.obj;	if (readCallback != null) readCallback.onReadFailure(new TimeoutException());	break;	}	case BleMsg.MSG_CHA_READ_RESULT:	{	readMsgInit();	BleReadCallback readCallback=(BleReadCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_READ_BUNDLE_STATUS);	byte[] value=bundle.getByteArray(BleMsg.KEY_READ_BUNDLE_VALUE);	if (readCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	readCallback.onReadSuccess(value);	}	 else {	readCallback.onReadFailure(new GattException(status));	}	}	break;	}	case BleMsg.MSG_READ_RSSI_START:	{	BleRssiCallback rssiCallback=(BleRssiCallback)msg.obj;	if (rssiCallback != null) rssiCallback.onRssiFailure(new TimeoutException());	break;	}	case BleMsg.MSG_READ_RSSI_RESULT:	{	rssiMsgInit();	BleRssiCallback rssiCallback=(BleRssiCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_READ_RSSI_BUNDLE_STATUS);	int value=bundle.getInt(BleMsg.KEY_READ_RSSI_BUNDLE_VALUE);	if (rssiCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	rssiCallback.onRssiSuccess(value);	}	 else {	rssiCallback.onRssiFailure(new GattException(status));	}	}	break;	}	case BleMsg.MSG_SET_MTU_START:	{	BleMtuChangedCallback mtuChangedCallback=(BleMtuChangedCallback)msg.obj;	if (mtuChangedCallback != null) mtuChangedCallback.onSetMTUFailure(new TimeoutException());	break;	}	case BleMsg.MSG_SET_MTU_RESULT:	{	mtuChangedMsgInit();	BleMtuChangedCallback mtuChangedCallback=(BleMtuChangedCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_SET_MTU_BUNDLE_STATUS);	int value=bundle.getInt(BleMsg.KEY_SET_MTU_BUNDLE_VALUE);	if (mtuChangedCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	mtuChangedCallback.onMtuChanged(value);	}	 else {	mtuChangedCallback.onSetMTUFailure(new GattException(status));	}	}	break;	}	}	}	}	;	}
@Override public void handleMessage(Message msg){	  super.handleMessage(msg);	switch (msg.what) {	case BleMsg.MSG_CHA_NOTIFY_START:	{	      BleNotifyCallback notifyCallback=(BleNotifyCallback)msg.obj;	      if (notifyCallback != null)       notifyCallback.onNotifyFailure(new TimeoutException());	      break;	    }	case BleMsg.MSG_CHA_NOTIFY_RESULT:	{	    notifyMsgInit();	    BleNotifyCallback notifyCallback=(BleNotifyCallback)msg.obj;	    Bundle bundle=msg.getData();	    int status=bundle.getInt(BleMsg.KEY_NOTIFY_BUNDLE_STATUS);	    if (notifyCallback != null) {	      if (status == BluetoothGatt.GATT_SUCCESS) {	        notifyCallback.onNotifySuccess();	      }	 else {	        notifyCallback.onNotifyFailure(new GattException(status));	      }	    }	    break;	  }	case BleMsg.MSG_CHA_NOTIFY_DATA_CHANGE:	{	  BleNotifyCallback notifyCallback=(BleNotifyCallback)msg.obj;	  Bundle bundle=msg.getData();	  byte[] value=bundle.getByteArray(BleMsg.KEY_NOTIFY_BUNDLE_VALUE);	  if (notifyCallback != null) {	    notifyCallback.onCharacteristicChanged(value);	  }	  break;	}	case BleMsg.MSG_CHA_INDICATE_START:	{	BleIndicateCallback indicateCallback=(BleIndicateCallback)msg.obj;	if (indicateCallback != null) indicateCallback.onIndicateFailure(new TimeoutException());	break;	}	case BleMsg.MSG_CHA_INDICATE_RESULT:	{	indicateMsgInit();	BleIndicateCallback indicateCallback=(BleIndicateCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_INDICATE_BUNDLE_STATUS);	if (indicateCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	  indicateCallback.onIndicateSuccess();	}	 else {	  indicateCallback.onIndicateFailure(new GattException(status));	}	}	break;	}	case BleMsg.MSG_CHA_INDICATE_DATA_CHANGE:	{	BleIndicateCallback indicateCallback=(BleIndicateCallback)msg.obj;	Bundle bundle=msg.getData();	byte[] value=bundle.getByteArray(BleMsg.KEY_INDICATE_BUNDLE_VALUE);	if (indicateCallback != null) {	indicateCallback.onCharacteristicChanged(value);	}	break;	}	case BleMsg.MSG_CHA_WRITE_START:	{	BleWriteCallback writeCallback=(BleWriteCallback)msg.obj;	if (writeCallback != null) {	writeCallback.onWriteFailure(new TimeoutException());	}	break;	}	case BleMsg.MSG_CHA_WRITE_RESULT:	{	writeMsgInit();	BleWriteCallback writeCallback=(BleWriteCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_WRITE_BUNDLE_STATUS);	byte[] value=bundle.getByteArray(BleMsg.KEY_WRITE_BUNDLE_VALUE);	if (writeCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	writeCallback.onWriteSuccess(BleWriteState.DATA_WRITE_SINGLE,BleWriteState.DATA_WRITE_SINGLE,value);	}	 else {	writeCallback.onWriteFailure(new GattException(status));	}	}	break;	}	case BleMsg.MSG_CHA_READ_START:	{	BleReadCallback readCallback=(BleReadCallback)msg.obj;	if (readCallback != null) readCallback.onReadFailure(new TimeoutException());	break;	}	case BleMsg.MSG_CHA_READ_RESULT:	{	readMsgInit();	BleReadCallback readCallback=(BleReadCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_READ_BUNDLE_STATUS);	byte[] value=bundle.getByteArray(BleMsg.KEY_READ_BUNDLE_VALUE);	if (readCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	readCallback.onReadSuccess(value);	}	 else {	readCallback.onReadFailure(new GattException(status));	}	}	break;	}	case BleMsg.MSG_READ_RSSI_START:	{	BleRssiCallback rssiCallback=(BleRssiCallback)msg.obj;	if (rssiCallback != null) rssiCallback.onRssiFailure(new TimeoutException());	break;	}	case BleMsg.MSG_READ_RSSI_RESULT:	{	rssiMsgInit();	BleRssiCallback rssiCallback=(BleRssiCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_READ_RSSI_BUNDLE_STATUS);	int value=bundle.getInt(BleMsg.KEY_READ_RSSI_BUNDLE_VALUE);	if (rssiCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	rssiCallback.onRssiSuccess(value);	}	 else {	rssiCallback.onRssiFailure(new GattException(status));	}	}	break;	}	case BleMsg.MSG_SET_MTU_START:	{	BleMtuChangedCallback mtuChangedCallback=(BleMtuChangedCallback)msg.obj;	if (mtuChangedCallback != null) mtuChangedCallback.onSetMTUFailure(new TimeoutException());	break;	}	case BleMsg.MSG_SET_MTU_RESULT:	{	mtuChangedMsgInit();	BleMtuChangedCallback mtuChangedCallback=(BleMtuChangedCallback)msg.obj;	Bundle bundle=msg.getData();	int status=bundle.getInt(BleMsg.KEY_SET_MTU_BUNDLE_STATUS);	int value=bundle.getInt(BleMsg.KEY_SET_MTU_BUNDLE_VALUE);	if (mtuChangedCallback != null) {	if (status == BluetoothGatt.GATT_SUCCESS) {	mtuChangedCallback.onMtuChanged(value);	}	 else {	mtuChangedCallback.onSetMTUFailure(new GattException(status));	}	}	break;	}	}	}
private BleConnector withUUID(UUID serviceUUID,UUID characteristicUUID){	  if (serviceUUID != null && mBluetoothGatt != null) {	    mGattService=mBluetoothGatt.getService(serviceUUID);	  }	  if (mGattService != null && characteristicUUID != null) {	    mCharacteristic=mGattService.getCharacteristic(characteristicUUID);	  }	  return this;	}
public BleConnector withUUIDString(String serviceUUID,String characteristicUUID){	  return withUUID(formUUID(serviceUUID),formUUID(characteristicUUID));	}
private UUID formUUID(String uuid){	  return uuid == null ? null : UUID.fromString(uuid);	}
public void enableCharacteristicNotify(BleNotifyCallback bleNotifyCallback,String uuid_notify){	  if (mCharacteristic != null && (mCharacteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    handleCharacteristicNotifyCallback(bleNotifyCallback,uuid_notify);	    setCharacteristicNotification(mBluetoothGatt,mCharacteristic,true,bleNotifyCallback);	  }	 else {	    if (bleNotifyCallback != null)     bleNotifyCallback.onNotifyFailure(new OtherException("this characteristic not support notify!"));	  }	}
public boolean disableCharacteristicNotify(){	  if (mCharacteristic != null && (mCharacteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    return setCharacteristicNotification(mBluetoothGatt,mCharacteristic,false,null);	  }	 else {	    return false;	  }	}
private boolean setCharacteristicNotification(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,boolean enable,BleNotifyCallback bleNotifyCallback){	  if (gatt == null || characteristic == null) {	    notifyMsgInit();	    if (bleNotifyCallback != null)     bleNotifyCallback.onNotifyFailure(new OtherException("gatt or characteristic equal null"));	    return false;	  }	  boolean success1=gatt.setCharacteristicNotification(characteristic,enable);	  if (!success1) {	    notifyMsgInit();	    if (bleNotifyCallback != null)     bleNotifyCallback.onNotifyFailure(new OtherException("gatt setCharacteristicNotification fail"));	    return false;	  }	  BluetoothGattDescriptor descriptor=characteristic.getDescriptor(formUUID(UUID_CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR));	  if (descriptor == null) {	    notifyMsgInit();	    if (bleNotifyCallback != null)     bleNotifyCallback.onNotifyFailure(new OtherException("descriptor equals null"));	    return false;	  }	 else {	    descriptor.setValue(enable ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);	    boolean success2=gatt.writeDescriptor(descriptor);	    if (!success2) {	      notifyMsgInit();	      if (bleNotifyCallback != null)       bleNotifyCallback.onNotifyFailure(new OtherException("gatt writeDescriptor fail"));	    }	    return success2;	  }	}
public void enableCharacteristicIndicate(BleIndicateCallback bleIndicateCallback,String uuid_indicate){	  if (mCharacteristic != null && (mCharacteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    handleCharacteristicIndicateCallback(bleIndicateCallback,uuid_indicate);	    setCharacteristicIndication(mBluetoothGatt,mCharacteristic,true,bleIndicateCallback);	  }	 else {	    if (bleIndicateCallback != null)     bleIndicateCallback.onIndicateFailure(new OtherException("this characteristic not support indicate!"));	  }	}
public boolean disableCharacteristicIndicate(){	  if (mCharacteristic != null && (mCharacteristic.getProperties() | BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    return setCharacteristicIndication(mBluetoothGatt,mCharacteristic,false,null);	  }	 else {	    return false;	  }	}
private boolean setCharacteristicIndication(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic,boolean enable,BleIndicateCallback bleIndicateCallback){	  if (gatt == null || characteristic == null) {	    indicateMsgInit();	    if (bleIndicateCallback != null)     bleIndicateCallback.onIndicateFailure(new OtherException("gatt or characteristic equal null"));	    return false;	  }	  boolean success1=gatt.setCharacteristicNotification(characteristic,enable);	  if (!success1) {	    indicateMsgInit();	    if (bleIndicateCallback != null)     bleIndicateCallback.onIndicateFailure(new OtherException("gatt setCharacteristicNotification fail"));	    return false;	  }	  BluetoothGattDescriptor descriptor=characteristic.getDescriptor(formUUID(UUID_CLIENT_CHARACTERISTIC_CONFIG_DESCRIPTOR));	  if (descriptor == null) {	    indicateMsgInit();	    if (bleIndicateCallback != null)     bleIndicateCallback.onIndicateFailure(new OtherException("descriptor equals null"));	    return false;	  }	 else {	    descriptor.setValue(enable ? BluetoothGattDescriptor.ENABLE_INDICATION_VALUE : BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);	    boolean success2=gatt.writeDescriptor(descriptor);	    if (!success2) {	      indicateMsgInit();	      if (bleIndicateCallback != null)       bleIndicateCallback.onIndicateFailure(new OtherException("gatt writeDescriptor fail"));	    }	    return success2;	  }	}
public void writeCharacteristic(byte[] data,BleWriteCallback bleWriteCallback,String uuid_write){	  if (data == null || data.length <= 0) {	    if (bleWriteCallback != null)     bleWriteCallback.onWriteFailure(new OtherException("the data to be written is empty"));	    return;	  }	  if (mCharacteristic == null || (mCharacteristic.getProperties() & (BluetoothGattCharacteristic.PROPERTY_WRITE | BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE)) == 0) {	    if (bleWriteCallback != null)     bleWriteCallback.onWriteFailure(new OtherException("this characteristic not support write!"));	    return;	  }	  if (mCharacteristic.setValue(data)) {	    handleCharacteristicWriteCallback(bleWriteCallback,uuid_write);	    if (!mBluetoothGatt.writeCharacteristic(mCharacteristic)) {	      writeMsgInit();	      if (bleWriteCallback != null)       bleWriteCallback.onWriteFailure(new OtherException("gatt writeCharacteristic fail"));	    }	  }	 else {	    if (bleWriteCallback != null)     bleWriteCallback.onWriteFailure(new OtherException("Updates the locally stored value of this characteristic fail"));	  }	}
public void readCharacteristic(BleReadCallback bleReadCallback,String uuid_read){	  if (mCharacteristic != null && (mCharacteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) > 0) {	    handleCharacteristicReadCallback(bleReadCallback,uuid_read);	    if (!mBluetoothGatt.readCharacteristic(mCharacteristic)) {	      readMsgInit();	      if (bleReadCallback != null)       bleReadCallback.onReadFailure(new OtherException("gatt readCharacteristic fail"));	    }	  }	 else {	    if (bleReadCallback != null)     bleReadCallback.onReadFailure(new OtherException("this characteristic not support read!"));	  }	}
public void readRemoteRssi(BleRssiCallback bleRssiCallback){	  handleRSSIReadCallback(bleRssiCallback);	  if (!mBluetoothGatt.readRemoteRssi()) {	    rssiMsgInit();	    if (bleRssiCallback != null)     bleRssiCallback.onRssiFailure(new OtherException("gatt readRemoteRssi fail"));	  }	}
public void setMtu(int requiredMtu,BleMtuChangedCallback bleMtuChangedCallback){	  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {	    handleSetMtuCallback(bleMtuChangedCallback);	    if (!mBluetoothGatt.requestMtu(requiredMtu)) {	      mtuChangedMsgInit();	      if (bleMtuChangedCallback != null)       bleMtuChangedCallback.onSetMTUFailure(new OtherException("gatt requestMtu fail"));	    }	  }	 else {	    if (bleMtuChangedCallback != null)     bleMtuChangedCallback.onSetMTUFailure(new OtherException("API level lower than 21"));	  }	}
private void handleCharacteristicNotifyCallback(BleNotifyCallback bleNotifyCallback,String uuid_notify){	  if (bleNotifyCallback != null) {	    notifyMsgInit();	    bleNotifyCallback.setKey(uuid_notify);	    bleNotifyCallback.setHandler(mHandler);	    mBleBluetooth.addNotifyCallback(uuid_notify,bleNotifyCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_CHA_NOTIFY_START,bleNotifyCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleCharacteristicIndicateCallback(BleIndicateCallback bleIndicateCallback,String uuid_indicate){	  if (bleIndicateCallback != null) {	    indicateMsgInit();	    bleIndicateCallback.setKey(uuid_indicate);	    bleIndicateCallback.setHandler(mHandler);	    mBleBluetooth.addIndicateCallback(uuid_indicate,bleIndicateCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_CHA_INDICATE_START,bleIndicateCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleCharacteristicWriteCallback(BleWriteCallback bleWriteCallback,String uuid_write){	  if (bleWriteCallback != null) {	    writeMsgInit();	    bleWriteCallback.setKey(uuid_write);	    bleWriteCallback.setHandler(mHandler);	    mBleBluetooth.addWriteCallback(uuid_write,bleWriteCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_CHA_WRITE_START,bleWriteCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleCharacteristicReadCallback(BleReadCallback bleReadCallback,String uuid_read){	  if (bleReadCallback != null) {	    readMsgInit();	    bleReadCallback.setKey(uuid_read);	    bleReadCallback.setHandler(mHandler);	    mBleBluetooth.addReadCallback(uuid_read,bleReadCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_CHA_READ_START,bleReadCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleRSSIReadCallback(BleRssiCallback bleRssiCallback){	  if (bleRssiCallback != null) {	    rssiMsgInit();	    bleRssiCallback.setHandler(mHandler);	    mBleBluetooth.addRssiCallback(bleRssiCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_READ_RSSI_START,bleRssiCallback),BleManager.getInstance().getOperateTimeout());	  }	}
private void handleSetMtuCallback(BleMtuChangedCallback bleMtuChangedCallback){	  if (bleMtuChangedCallback != null) {	    mtuChangedMsgInit();	    bleMtuChangedCallback.setHandler(mHandler);	    mBleBluetooth.addMtuChangedCallback(bleMtuChangedCallback);	    mHandler.sendMessageDelayed(mHandler.obtainMessage(BleMsg.MSG_SET_MTU_START,bleMtuChangedCallback),BleManager.getInstance().getOperateTimeout());	  }	}
public void notifyMsgInit(){	  mHandler.removeMessages(BleMsg.MSG_CHA_NOTIFY_START);	}
public void indicateMsgInit(){	  mHandler.removeMessages(BleMsg.MSG_CHA_INDICATE_START);	}
public void writeMsgInit(){	  mHandler.removeMessages(BleMsg.MSG_CHA_WRITE_START);	}
public void readMsgInit(){	  mHandler.removeMessages(BleMsg.MSG_CHA_READ_START);	}
public void rssiMsgInit(){	  mHandler.removeMessages(BleMsg.MSG_READ_RSSI_START);	}
public void mtuChangedMsgInit(){	  mHandler.removeMessages(BleMsg.MSG_SET_MTU_START);	}
public BleDevice(BluetoothDevice device){	  mDevice=device;	}
public BleDevice(BluetoothDevice device,int rssi,byte[] scanRecord,long timestampNanos){	  mDevice=device;	  mScanRecord=scanRecord;	  mRssi=rssi;	  mTimestampNanos=timestampNanos;	}
protected BleDevice(Parcel in){	  mDevice=in.readParcelable(BluetoothDevice.class.getClassLoader());	  mScanRecord=in.createByteArray();	  mRssi=in.readInt();	  mTimestampNanos=in.readLong();	}
@Override public void writeToParcel(Parcel dest,int flags){	  dest.writeParcelable(mDevice,flags);	  dest.writeByteArray(mScanRecord);	  dest.writeInt(mRssi);	  dest.writeLong(mTimestampNanos);	}
@Override public int describeContents(){	  return 0;	}
@Override public BleDevice createFromParcel(Parcel in){	  return new BleDevice(in);	}
@Override public BleDevice[] newArray(int size){	  return new BleDevice[size];	}
public String getName(){	  if (mDevice != null)   return mDevice.getName();	  return null;	}
public String getMac(){	  if (mDevice != null)   return mDevice.getAddress();	  return null;	}
public String getKey(){	  if (mDevice != null)   return mDevice.getName() + mDevice.getAddress();	  return "";	}
public BluetoothDevice getDevice(){	  return mDevice;	}
public void setDevice(BluetoothDevice device){	  this.mDevice=device;	}
public byte[] getScanRecord(){	  return mScanRecord;	}
public void setScanRecord(byte[] scanRecord){	  this.mScanRecord=scanRecord;	}
public int getRssi(){	  return mRssi;	}
public void setRssi(int rssi){	  this.mRssi=rssi;	}
public long getTimestampNanos(){	  return mTimestampNanos;	}
public void setTimestampNanos(long timestampNanos){	  this.mTimestampNanos=timestampNanos;	}
public BleConnectStateParameter(int status){	  this.status=status;	}
public int getStatus(){	  return status;	}
public void setStatus(int status){	  this.status=status;	}
public boolean isActive(){	  return isActive;	}
public void setActive(boolean active){	  isActive=active;	}
public static BleManager getInstance(){	  return BleManagerHolder.sBleManager;	}
public void init(Application app){	  if (context == null && app != null) {	    context=app;	    if (isSupportBle()) {	      bluetoothManager=(BluetoothManager)context.getSystemService(Context.BLUETOOTH_SERVICE);	    }	    bluetoothAdapter=BluetoothAdapter.getDefaultAdapter();	    multipleBluetoothController=new MultipleBluetoothController();	    bleScanRuleConfig=new BleScanRuleConfig();	  }	}
public Context getContext(){	  return context;	}
public BluetoothManager getBluetoothManager(){	  return bluetoothManager;	}
public BluetoothAdapter getBluetoothAdapter(){	  return bluetoothAdapter;	}
public BleScanRuleConfig getScanRuleConfig(){	  return bleScanRuleConfig;	}
public MultipleBluetoothController getMultipleBluetoothController(){	  return multipleBluetoothController;	}
public void initScanRule(BleScanRuleConfig config){	  this.bleScanRuleConfig=config;	}
public int getMaxConnectCount(){	  return maxConnectCount;	}
public BleManager setMaxConnectCount(int count){	  if (count > DEFAULT_MAX_MULTIPLE_DEVICE)   count=DEFAULT_MAX_MULTIPLE_DEVICE;	  this.maxConnectCount=count;	  return this;	}
public int getOperateTimeout(){	  return operateTimeout;	}
public BleManager setOperateTimeout(int count){	  this.operateTimeout=count;	  return this;	}
public int getReConnectCount(){	  return reConnectCount;	}
public long getReConnectInterval(){	  return reConnectInterval;	}
public BleManager setReConnectCount(int count){	  return setReConnectCount(count,DEFAULT_CONNECT_RETRY_INTERVAL);	}
public BleManager setReConnectCount(int count,long interval){	  if (count > 10)   count=10;	  if (interval < 0)   interval=0;	  this.reConnectCount=count;	  this.reConnectInterval=interval;	  return this;	}
public int getSplitWriteNum(){	  return splitWriteNum;	}
public BleManager setSplitWriteNum(int num){	  this.splitWriteNum=num;	  return this;	}
public long getConnectOverTime(){	  return connectOverTime;	}
public BleManager setConnectOverTime(long time){	  if (time <= 0) {	    time=100;	  }	  this.connectOverTime=time;	  return this;	}
public BleManager enableLog(boolean enable){	  BleLog.isPrint=enable;	  return this;	}
public void scan(BleScanCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleScanCallback can not be Null!");	  }	  if (!isBlueEnable()) {	    BleLog.e("Bluetooth not enable!");	    callback.onScanStarted(false);	    return;	  }	  UUID[] serviceUuids=bleScanRuleConfig.getServiceUuids();	  String[] deviceNames=bleScanRuleConfig.getDeviceNames();	  String deviceMac=bleScanRuleConfig.getDeviceMac();	  boolean fuzzy=bleScanRuleConfig.isFuzzy();	  long timeOut=bleScanRuleConfig.getScanTimeOut();	  BleScanner.getInstance().scan(serviceUuids,deviceNames,deviceMac,fuzzy,timeOut,callback);	}
public void scanAndConnect(BleScanAndConnectCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleScanAndConnectCallback can not be Null!");	  }	  if (!isBlueEnable()) {	    BleLog.e("Bluetooth not enable!");	    callback.onScanStarted(false);	    return;	  }	  UUID[] serviceUuids=bleScanRuleConfig.getServiceUuids();	  String[] deviceNames=bleScanRuleConfig.getDeviceNames();	  String deviceMac=bleScanRuleConfig.getDeviceMac();	  boolean fuzzy=bleScanRuleConfig.isFuzzy();	  long timeOut=bleScanRuleConfig.getScanTimeOut();	  BleScanner.getInstance().scanAndConnect(serviceUuids,deviceNames,deviceMac,fuzzy,timeOut,callback);	}
public BluetoothGatt connect(BleDevice bleDevice,BleGattCallback bleGattCallback){	  if (bleGattCallback == null) {	    throw new IllegalArgumentException("BleGattCallback can not be Null!");	  }	  if (!isBlueEnable()) {	    BleLog.e("Bluetooth not enable!");	    bleGattCallback.onConnectFail(bleDevice,new OtherException("Bluetooth not enable!"));	    return null;	  }	  if (Looper.myLooper() == null || Looper.myLooper() != Looper.getMainLooper()) {	    BleLog.w("Be careful: currentThread is not MainThread!");	  }	  if (bleDevice == null || bleDevice.getDevice() == null) {	    bleGattCallback.onConnectFail(bleDevice,new OtherException("Not Found Device Exception Occurred!"));	  }	 else {	    BleBluetooth bleBluetooth=multipleBluetoothController.buildConnectingBle(bleDevice);	    boolean autoConnect=bleScanRuleConfig.isAutoConnect();	    return bleBluetooth.connect(bleDevice,autoConnect,bleGattCallback);	  }	  return null;	}
public BluetoothGatt connect(String mac,BleGattCallback bleGattCallback){	  BluetoothDevice bluetoothDevice=getBluetoothAdapter().getRemoteDevice(mac);	  BleDevice bleDevice=new BleDevice(bluetoothDevice,0,null,0);	  return connect(bleDevice,bleGattCallback);	}
public void cancelScan(){	  BleScanner.getInstance().stopLeScan();	}
public void notify(BleDevice bleDevice,String uuid_service,String uuid_notify,BleNotifyCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleNotifyCallback can not be Null!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onNotifyFailure(new OtherException("This device not connect!"));	  }	 else {	    bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_notify).enableCharacteristicNotify(callback,uuid_notify);	  }	}
public void indicate(BleDevice bleDevice,String uuid_service,String uuid_indicate,BleIndicateCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleIndicateCallback can not be Null!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onIndicateFailure(new OtherException("This device not connect!"));	  }	 else {	    bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_indicate).enableCharacteristicIndicate(callback,uuid_indicate);	  }	}
public boolean stopNotify(BleDevice bleDevice,String uuid_service,String uuid_notify){	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    return false;	  }	  boolean success=bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_notify).disableCharacteristicNotify();	  if (success) {	    bleBluetooth.removeNotifyCallback(uuid_notify);	  }	  return success;	}
public boolean stopIndicate(BleDevice bleDevice,String uuid_service,String uuid_indicate){	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    return false;	  }	  boolean success=bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_indicate).disableCharacteristicIndicate();	  if (success) {	    bleBluetooth.removeIndicateCallback(uuid_indicate);	  }	  return success;	}
public void write(BleDevice bleDevice,String uuid_service,String uuid_write,byte[] data,BleWriteCallback callback){	  write(bleDevice,uuid_service,uuid_write,data,true,callback);	}
public void write(BleDevice bleDevice,String uuid_service,String uuid_write,byte[] data,boolean split,BleWriteCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleWriteCallback can not be Null!");	  }	  if (data == null) {	    BleLog.e("data is Null!");	    callback.onWriteFailure(new OtherException("data is Null!"));	    return;	  }	  if (data.length > 20 && !split) {	    BleLog.w("Be careful: data's length beyond 20! Ensure MTU higher than 23, or use spilt write!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onWriteFailure(new OtherException("This device not connect!"));	  }	 else {	    if (split && data.length > 20) {	      new SplitWriter().splitWrite(bleBluetooth,uuid_service,uuid_write,data,callback);	    }	 else {	      bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_write).writeCharacteristic(data,callback,uuid_write);	    }	  }	}
public void read(BleDevice bleDevice,String uuid_service,String uuid_read,BleReadCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleReadCallback can not be Null!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onReadFailure(new OtherException("This device is not connected!"));	  }	 else {	    bleBluetooth.newBleConnector().withUUIDString(uuid_service,uuid_read).readCharacteristic(callback,uuid_read);	  }	}
public void readRssi(BleDevice bleDevice,BleRssiCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleRssiCallback can not be Null!");	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onRssiFailure(new OtherException("This device is not connected!"));	  }	 else {	    bleBluetooth.newBleConnector().readRemoteRssi(callback);	  }	}
public void setMtu(BleDevice bleDevice,int mtu,BleMtuChangedCallback callback){	  if (callback == null) {	    throw new IllegalArgumentException("BleMtuChangedCallback can not be Null!");	  }	  if (mtu > DEFAULT_MAX_MTU) {	    BleLog.e("requiredMtu should lower than 512 !");	    callback.onSetMTUFailure(new OtherException("requiredMtu should lower than 512 !"));	    return;	  }	  if (mtu < DEFAULT_MTU) {	    BleLog.e("requiredMtu should higher than 23 !");	    callback.onSetMTUFailure(new OtherException("requiredMtu should higher than 23 !"));	    return;	  }	  BleBluetooth bleBluetooth=multipleBluetoothController.getBleBluetooth(bleDevice);	  if (bleBluetooth == null) {	    callback.onSetMTUFailure(new OtherException("This device is not connected!"));	  }	 else {	    bleBluetooth.newBleConnector().setMtu(mtu,callback);	  }	}
public boolean isSupportBle(){	  return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2 && context.getApplicationContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);	}
public void enableBluetooth(){	  if (bluetoothAdapter != null) {	    bluetoothAdapter.enable();	  }	}
public void disableBluetooth(){	  if (bluetoothAdapter != null) {	    if (bluetoothAdapter.isEnabled())     bluetoothAdapter.disable();	  }	}
public boolean isBlueEnable(){	  return bluetoothAdapter != null && bluetoothAdapter.isEnabled();	}
public BleDevice convertBleDevice(BluetoothDevice bluetoothDevice){	  return new BleDevice(bluetoothDevice);	}
@TargetApi(Build.VERSION_CODES.LOLLIPOP) public BleDevice convertBleDevice(ScanResult scanResult){	  if (scanResult == null) {	    throw new IllegalArgumentException("scanResult can not be Null!");	  }	  BluetoothDevice bluetoothDevice=scanResult.getDevice();	  int rssi=scanResult.getRssi();	  ScanRecord scanRecord=scanResult.getScanRecord();	  byte[] bytes=null;	  if (scanRecord != null)   bytes=scanRecord.getBytes();	  long timestampNanos=scanResult.getTimestampNanos();	  return new BleDevice(bluetoothDevice,rssi,bytes,timestampNanos);	}
public BleBluetooth getBleBluetooth(BleDevice bleDevice){	  if (multipleBluetoothController != null) {	    return multipleBluetoothController.getBleBluetooth(bleDevice);	  }	  return null;	}
public BluetoothGatt getBluetoothGatt(BleDevice bleDevice){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   return bleBluetooth.getBluetoothGatt();	  return null;	}
public List<BluetoothGattService> getBluetoothGattServices(BleDevice bleDevice){	  BluetoothGatt gatt=getBluetoothGatt(bleDevice);	  if (gatt != null) {	    return gatt.getServices();	  }	  return null;	}
public List<BluetoothGattCharacteristic> getBluetoothGattCharacteristics(BluetoothGattService service){	  return service.getCharacteristics();	}
public void removeConnectGattCallback(BleDevice bleDevice){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   bleBluetooth.removeConnectGattCallback();	}
public void removeRssiCallback(BleDevice bleDevice){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   bleBluetooth.removeRssiCallback();	}
public void removeMtuChangedCallback(BleDevice bleDevice){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   bleBluetooth.removeMtuChangedCallback();	}
public void removeNotifyCallback(BleDevice bleDevice,String uuid_notify){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   bleBluetooth.removeNotifyCallback(uuid_notify);	}
public void removeIndicateCallback(BleDevice bleDevice,String uuid_indicate){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   bleBluetooth.removeIndicateCallback(uuid_indicate);	}
public void removeWriteCallback(BleDevice bleDevice,String uuid_write){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   bleBluetooth.removeWriteCallback(uuid_write);	}
public void removeReadCallback(BleDevice bleDevice,String uuid_read){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   bleBluetooth.removeReadCallback(uuid_read);	}
public void clearCharacterCallback(BleDevice bleDevice){	  BleBluetooth bleBluetooth=getBleBluetooth(bleDevice);	  if (bleBluetooth != null)   bleBluetooth.clearCharacterCallback();	}
public BleScanState getScanSate(){	  return BleScanner.getInstance().getScanState();	}
public List<BleDevice> getAllConnectedDevice(){	  if (multipleBluetoothController == null)   return null;	  return multipleBluetoothController.getDeviceList();	}
public int getConnectState(BleDevice bleDevice){	  if (bleDevice != null) {	    return bluetoothManager.getConnectionState(bleDevice.getDevice(),BluetoothProfile.GATT);	  }	 else {	    return BluetoothProfile.STATE_DISCONNECTED;	  }	}
public boolean isConnected(BleDevice bleDevice){	  return getConnectState(bleDevice) == BluetoothProfile.STATE_CONNECTED;	}
public boolean isConnected(String mac){	  List<BleDevice> list=getAllConnectedDevice();	  for (  BleDevice bleDevice : list) {	    if (bleDevice != null) {	      if (bleDevice.getMac().equals(mac)) {	        return true;	      }	    }	  }	  return false;	}
public void disconnect(BleDevice bleDevice){	  if (multipleBluetoothController != null) {	    multipleBluetoothController.disconnect(bleDevice);	  }	}
public void disconnectAllDevice(){	  if (multipleBluetoothController != null) {	    multipleBluetoothController.disconnectAllDevice();	  }	}
public void destroy(){	  if (multipleBluetoothController != null) {	    multipleBluetoothController.destroy();	  }	}
public BleLruHashMap(int saveSize){	  super((int)Math.ceil(saveSize / 0.75) + 1,0.75f,true);	  MAX_SIZE=saveSize;	}
@Override protected boolean removeEldestEntry(java.util.Map.Entry eldest){	  if (size() > MAX_SIZE && eldest.getValue() instanceof BleBluetooth) {	    ((BleBluetooth)eldest.getValue()).disconnect();	  }	  return size() > MAX_SIZE;	}
@Override public String toString(){	  StringBuilder sb=new StringBuilder();	  for (  Entry<K,V> entry : entrySet()) {	    sb.append(String.format("%s:%s ",entry.getKey(),entry.getValue()));	  }	  return sb.toString();	}
public static void d(String msg){	  if (isPrint && msg != null)   Log.d(defaultTag,msg);	}
public static void i(String msg){	  if (isPrint && msg != null)   Log.i(defaultTag,msg);	}
public static void w(String msg){	  if (isPrint && msg != null)   Log.w(defaultTag,msg);	}
public static void e(String msg){	  if (isPrint && msg != null)   Log.e(defaultTag,msg);	}
public static char[] encodeHex(byte[] data){	  return encodeHex(data,true);	}
public static char[] encodeHex(byte[] data,boolean toLowerCase){	  return encodeHex(data,toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);	}
protected static char[] encodeHex(byte[] data,char[] toDigits){	  if (data == null)   return null;	  int l=data.length;	  char[] out=new char[l << 1];	  for (int i=0, j=0; i < l; i++) {	    out[j++]=toDigits[(0xF0 & data[i]) >>> 4];	    out[j++]=toDigits[0x0F & data[i]];	  }	  return out;	}
public static String encodeHexStr(byte[] data){	  return encodeHexStr(data,true);	}
public static String encodeHexStr(byte[] data,boolean toLowerCase){	  return encodeHexStr(data,toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);	}
protected static String encodeHexStr(byte[] data,char[] toDigits){	  return new String(encodeHex(data,toDigits));	}
public static String formatHexString(byte[] data){	  return formatHexString(data,false);	}
public static String formatHexString(byte[] data,boolean addSpace){	  if (data == null || data.length < 1)   return null;	  StringBuilder sb=new StringBuilder();	  for (int i=0; i < data.length; i++) {	    String hex=Integer.toHexString(data[i] & 0xFF);	    if (hex.length() == 1) {	      hex='0' + hex;	    }	    sb.append(hex);	    if (addSpace)     sb.append(" ");	  }	  return sb.toString().trim();	}
public static byte[] decodeHex(char[] data){	  int len=data.length;	  if ((len & 0x01) != 0) {	    throw new RuntimeException("Odd number of characters.");	  }	  byte[] out=new byte[len >> 1];	  for (int i=0, j=0; j < len; i++) {	    int f=toDigit(data[j],j) << 4;	    j++;	    f=f | toDigit(data[j],j);	    j++;	    out[i]=(byte)(f & 0xFF);	  }	  return out;	}
protected static int toDigit(char ch,int index){	  int digit=Character.digit(ch,16);	  if (digit == -1) {	    throw new RuntimeException("Illegal hexadecimal character " + ch + " at index "+ index);	  }	  return digit;	}
public static byte[] hexStringToBytes(String hexString){	  if (hexString == null || hexString.equals("")) {	    return null;	  }	  hexString=hexString.toUpperCase();	  int length=hexString.length() / 2;	  char[] hexChars=hexString.toCharArray();	  byte[] d=new byte[length];	  for (int i=0; i < length; i++) {	    int pos=i * 2;	    d[i]=(byte)(charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));	  }	  return d;	}
public static byte charToByte(char c){	  return (byte)"0123456789ABCDEF".indexOf(c);	}
public static String extractData(byte[] data,int position){	  return HexUtil.formatHexString(new byte[]{data[position]});	}
public ConnectException(BluetoothGatt bluetoothGatt,int gattStatus){	  super(ERROR_CODE_GATT,"Gatt Exception Occurred! ");	  this.bluetoothGatt=bluetoothGatt;	  this.gattStatus=gattStatus;	}
public int getGattStatus(){	  return gattStatus;	}
public ConnectException setGattStatus(int gattStatus){	  this.gattStatus=gattStatus;	  return this;	}
public BluetoothGatt getBluetoothGatt(){	  return bluetoothGatt;	}
public ConnectException setBluetoothGatt(BluetoothGatt bluetoothGatt){	  this.bluetoothGatt=bluetoothGatt;	  return this;	}
@Override public String toString(){	  return "ConnectException{" + "gattStatus=" + gattStatus + ", bluetoothGatt="+ bluetoothGatt+ "} "+ super.toString();	}
public OtherException(String description){	  super(ERROR_CODE_OTHER,description);	}
public TimeoutException(){	  super(ERROR_CODE_TIMEOUT,"Timeout Exception Occurred!");	}
public BleException(int code,String description){	  this.code=code;	  this.description=description;	}
public int getCode(){	  return code;	}
public BleException setCode(int code){	  this.code=code;	  return this;	}
public String getDescription(){	  return description;	}
public BleException setDescription(String description){	  this.description=description;	  return this;	}
@Override public String toString(){	  return "BleException { " + "code=" + code + ", description='"+ description+ '\''+ '}';	}
public GattException(int gattStatus){	  super(ERROR_CODE_GATT,"Gatt Exception Occurred! ");	  this.gattStatus=gattStatus;	}
public int getGattStatus(){	  return gattStatus;	}
public GattException setGattStatus(int gattStatus){	  this.gattStatus=gattStatus;	  return this;	}
@Override public String toString(){	  return "GattException{" + "gattStatus=" + gattStatus + "} "+ super.toString();	}
public ApplicationTest(){	  super(Application.class);	}
@Override protected void onCreate(Bundle savedInstanceState){	  super.onCreate(savedInstanceState);	  setContentView(R.layout.activity_main);	  initView();	  BleManager.getInstance().init(getApplication());	  BleManager.getInstance().enableLog(true).setReConnectCount(1,5000).setConnectOverTime(20000).setOperateTimeout(5000);	}
@Override protected void onResume(){	  super.onResume();	  showConnectedDevice();	}
@Override protected void onDestroy(){	  super.onDestroy();	  BleManager.getInstance().disconnectAllDevice();	  BleManager.getInstance().destroy();	}
@Override public void onClick(View v){	switch (v.getId()) {	case R.id.btn_scan:	    if (btn_scan.getText().equals(getString(R.string.start_scan))) {	      checkPermissions();	    }	 else     if (btn_scan.getText().equals(getString(R.string.stop_scan))) {	      BleManager.getInstance().cancelScan();	    }	  break;	case R.id.txt_setting:	if (layout_setting.getVisibility() == View.VISIBLE) {	  layout_setting.setVisibility(View.GONE);	  txt_setting.setText(getString(R.string.expand_search_settings));	}	 else {	  layout_setting.setVisibility(View.VISIBLE);	  txt_setting.setText(getString(R.string.retrieve_search_settings));	}	break;	}	}
private void initView(){	  Toolbar toolbar=(Toolbar)findViewById(R.id.toolbar);	  setSupportActionBar(toolbar);	  btn_scan=(Button)findViewById(R.id.btn_scan);	  btn_scan.setText(getString(R.string.start_scan));	  btn_scan.setOnClickListener(this);	  et_name=(EditText)findViewById(R.id.et_name);	  et_mac=(EditText)findViewById(R.id.et_mac);	  et_uuid=(EditText)findViewById(R.id.et_uuid);	  sw_auto=(Switch)findViewById(R.id.sw_auto);	  layout_setting=(LinearLayout)findViewById(R.id.layout_setting);	  txt_setting=(TextView)findViewById(R.id.txt_setting);	  txt_setting.setOnClickListener(this);	  layout_setting.setVisibility(View.GONE);	  txt_setting.setText(getString(R.string.expand_search_settings));	  img_loading=(ImageView)findViewById(R.id.img_loading);	  operatingAnim=AnimationUtils.loadAnimation(this,R.anim.rotate);	  operatingAnim.setInterpolator(new LinearInterpolator());	  progressDialog=new ProgressDialog(this);	  mDeviceAdapter=new DeviceAdapter(this);	  mDeviceAdapter.setOnDeviceClickListener(new DeviceAdapter.OnDeviceClickListener(){	    @Override public void onConnect(    BleDevice bleDevice){	      if (!BleManager.getInstance().isConnected(bleDevice)) {	        BleManager.getInstance().cancelScan();	        connect(bleDevice);	      }	    }	    @Override public void onDisConnect(    final BleDevice bleDevice){	      if (BleManager.getInstance().isConnected(bleDevice)) {	        BleManager.getInstance().disconnect(bleDevice);	      }	    }	    @Override public void onDetail(    BleDevice bleDevice){	      if (BleManager.getInstance().isConnected(bleDevice)) {	        Intent intent=new Intent(MainActivity.this,OperationActivity.class);	        intent.putExtra(OperationActivity.KEY_DATA,bleDevice);	        startActivity(intent);	      }	    }	  }	);	  ListView listView_device=(ListView)findViewById(R.id.list_device);	  listView_device.setAdapter(mDeviceAdapter);	}
@Override public void onConnect(BleDevice bleDevice){	  if (!BleManager.getInstance().isConnected(bleDevice)) {	    BleManager.getInstance().cancelScan();	    connect(bleDevice);	  }	}
@Override public void onDisConnect(final BleDevice bleDevice){	  if (BleManager.getInstance().isConnected(bleDevice)) {	    BleManager.getInstance().disconnect(bleDevice);	  }	}
@Override public void onDetail(BleDevice bleDevice){	  if (BleManager.getInstance().isConnected(bleDevice)) {	    Intent intent=new Intent(MainActivity.this,OperationActivity.class);	    intent.putExtra(OperationActivity.KEY_DATA,bleDevice);	    startActivity(intent);	  }	}
private void showConnectedDevice(){	  List<BleDevice> deviceList=BleManager.getInstance().getAllConnectedDevice();	  mDeviceAdapter.clearConnectedDevice();	  for (  BleDevice bleDevice : deviceList) {	    mDeviceAdapter.addDevice(bleDevice);	  }	  mDeviceAdapter.notifyDataSetChanged();	}
private void setScanRule(){	  String[] uuids;	  String str_uuid=et_uuid.getText().toString();	  if (TextUtils.isEmpty(str_uuid)) {	    uuids=null;	  }	 else {	    uuids=str_uuid.split(",");	  }	  UUID[] serviceUuids=null;	  if (uuids != null && uuids.length > 0) {	    serviceUuids=new UUID[uuids.length];	    for (int i=0; i < uuids.length; i++) {	      String name=uuids[i];	      String[] components=name.split("-");	      if (components.length != 5) {	        serviceUuids[i]=null;	      }	 else {	        serviceUuids[i]=UUID.fromString(uuids[i]);	      }	    }	  }	  String[] names;	  String str_name=et_name.getText().toString();	  if (TextUtils.isEmpty(str_name)) {	    names=null;	  }	 else {	    names=str_name.split(",");	  }	  String mac=et_mac.getText().toString();	  boolean isAutoConnect=sw_auto.isChecked();	  BleScanRuleConfig scanRuleConfig=new BleScanRuleConfig.Builder().setServiceUuids(serviceUuids).setDeviceName(true,names).setDeviceMac(mac).setAutoConnect(isAutoConnect).setScanTimeOut(10000).build();	  BleManager.getInstance().initScanRule(scanRuleConfig);	}
private void startScan(){	  BleManager.getInstance().scan(new BleScanCallback(){	    @Override public void onScanStarted(    boolean success){	      mDeviceAdapter.clearScanDevice();	      mDeviceAdapter.notifyDataSetChanged();	      img_loading.startAnimation(operatingAnim);	      img_loading.setVisibility(View.VISIBLE);	      btn_scan.setText(getString(R.string.stop_scan));	    }	    @Override public void onLeScan(    BleDevice bleDevice){	      super.onLeScan(bleDevice);	    }	    @Override public void onScanning(    BleDevice bleDevice){	      mDeviceAdapter.addDevice(bleDevice);	      mDeviceAdapter.notifyDataSetChanged();	    }	    @Override public void onScanFinished(    List<BleDevice> scanResultList){	      img_loading.clearAnimation();	      img_loading.setVisibility(View.INVISIBLE);	      btn_scan.setText(getString(R.string.start_scan));	    }	  }	);	}
@Override public void onScanStarted(boolean success){	  mDeviceAdapter.clearScanDevice();	  mDeviceAdapter.notifyDataSetChanged();	  img_loading.startAnimation(operatingAnim);	  img_loading.setVisibility(View.VISIBLE);	  btn_scan.setText(getString(R.string.stop_scan));	}
@Override public void onLeScan(BleDevice bleDevice){	  super.onLeScan(bleDevice);	}
@Override public void onScanning(BleDevice bleDevice){	  mDeviceAdapter.addDevice(bleDevice);	  mDeviceAdapter.notifyDataSetChanged();	}
@Override public void onScanFinished(List<BleDevice> scanResultList){	  img_loading.clearAnimation();	  img_loading.setVisibility(View.INVISIBLE);	  btn_scan.setText(getString(R.string.start_scan));	}
private void connect(final BleDevice bleDevice){	  BleManager.getInstance().connect(bleDevice,new BleGattCallback(){	    @Override public void onStartConnect(){	      progressDialog.show();	    }	    @Override public void onConnectFail(    BleDevice bleDevice,    BleException exception){	      img_loading.clearAnimation();	      img_loading.setVisibility(View.INVISIBLE);	      btn_scan.setText(getString(R.string.start_scan));	      progressDialog.dismiss();	      Toast.makeText(MainActivity.this,getString(R.string.connect_fail),Toast.LENGTH_LONG).show();	    }	    @Override public void onConnectSuccess(    BleDevice bleDevice,    BluetoothGatt gatt,    int status){	      progressDialog.dismiss();	      mDeviceAdapter.addDevice(bleDevice);	      mDeviceAdapter.notifyDataSetChanged();	    }	    @Override public void onDisConnected(    boolean isActiveDisConnected,    BleDevice bleDevice,    BluetoothGatt gatt,    int status){	      progressDialog.dismiss();	      mDeviceAdapter.removeDevice(bleDevice);	      mDeviceAdapter.notifyDataSetChanged();	      if (isActiveDisConnected) {	        Toast.makeText(MainActivity.this,getString(R.string.active_disconnected),Toast.LENGTH_LONG).show();	      }	 else {	        Toast.makeText(MainActivity.this,getString(R.string.disconnected),Toast.LENGTH_LONG).show();	        ObserverManager.getInstance().notifyObserver(bleDevice);	      }	    }	  }	);	}
@Override public void onStartConnect(){	  progressDialog.show();	}
@Override public void onConnectFail(BleDevice bleDevice,BleException exception){	  img_loading.clearAnimation();	  img_loading.setVisibility(View.INVISIBLE);	  btn_scan.setText(getString(R.string.start_scan));	  progressDialog.dismiss();	  Toast.makeText(MainActivity.this,getString(R.string.connect_fail),Toast.LENGTH_LONG).show();	}
@Override public void onConnectSuccess(BleDevice bleDevice,BluetoothGatt gatt,int status){	  progressDialog.dismiss();	  mDeviceAdapter.addDevice(bleDevice);	  mDeviceAdapter.notifyDataSetChanged();	}
@Override public void onDisConnected(boolean isActiveDisConnected,BleDevice bleDevice,BluetoothGatt gatt,int status){	  progressDialog.dismiss();	  mDeviceAdapter.removeDevice(bleDevice);	  mDeviceAdapter.notifyDataSetChanged();	  if (isActiveDisConnected) {	    Toast.makeText(MainActivity.this,getString(R.string.active_disconnected),Toast.LENGTH_LONG).show();	  }	 else {	    Toast.makeText(MainActivity.this,getString(R.string.disconnected),Toast.LENGTH_LONG).show();	    ObserverManager.getInstance().notifyObserver(bleDevice);	  }	}
private void readRssi(BleDevice bleDevice){	  BleManager.getInstance().readRssi(bleDevice,new BleRssiCallback(){	    @Override public void onRssiFailure(    BleException exception){	      Log.i(TAG,"onRssiFailure" + exception.toString());	    }	    @Override public void onRssiSuccess(    int rssi){	      Log.i(TAG,"onRssiSuccess: " + rssi);	    }	  }	);	}
@Override public void onRssiFailure(BleException exception){	  Log.i(TAG,"onRssiFailure" + exception.toString());	}
@Override public void onRssiSuccess(int rssi){	  Log.i(TAG,"onRssiSuccess: " + rssi);	}
private void setMtu(BleDevice bleDevice,int mtu){	  BleManager.getInstance().setMtu(bleDevice,mtu,new BleMtuChangedCallback(){	    @Override public void onSetMTUFailure(    BleException exception){	      Log.i(TAG,"onsetMTUFailure" + exception.toString());	    }	    @Override public void onMtuChanged(    int mtu){	      Log.i(TAG,"onMtuChanged: " + mtu);	    }	  }	);	}
@Override public void onSetMTUFailure(BleException exception){	  Log.i(TAG,"onsetMTUFailure" + exception.toString());	}
@Override public void onMtuChanged(int mtu){	  Log.i(TAG,"onMtuChanged: " + mtu);	}
@Override public final void onRequestPermissionsResult(int requestCode,@NonNull String[] permissions,@NonNull int[] grantResults){	  super.onRequestPermissionsResult(requestCode,permissions,grantResults);	switch (requestCode) {	case REQUEST_CODE_PERMISSION_LOCATION:	    if (grantResults.length > 0) {	      for (int i=0; i < grantResults.length; i++) {	        if (grantResults[i] == PackageManager.PERMISSION_GRANTED) {	          onPermissionGranted(permissions[i]);	        }	      }	    }	  break;	}	}
private void checkPermissions(){	  BluetoothAdapter bluetoothAdapter=BluetoothAdapter.getDefaultAdapter();	  if (!bluetoothAdapter.isEnabled()) {	    Toast.makeText(this,getString(R.string.please_open_blue),Toast.LENGTH_LONG).show();	    return;	  }	  String[] permissions={Manifest.permission.ACCESS_FINE_LOCATION};	  List<String> permissionDeniedList=new ArrayList<>();	  for (  String permission : permissions) {	    int permissionCheck=ContextCompat.checkSelfPermission(this,permission);	    if (permissionCheck == PackageManager.PERMISSION_GRANTED) {	      onPermissionGranted(permission);	    }	 else {	      permissionDeniedList.add(permission);	    }	  }	  if (!permissionDeniedList.isEmpty()) {	    String[] deniedPermissions=permissionDeniedList.toArray(new String[permissionDeniedList.size()]);	    ActivityCompat.requestPermissions(this,deniedPermissions,REQUEST_CODE_PERMISSION_LOCATION);	  }	}
private void onPermissionGranted(String permission){	switch (permission) {	case Manifest.permission.ACCESS_FINE_LOCATION:	    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !checkGPSIsOpen()) {	      new AlertDialog.Builder(this).setTitle(R.string.notifyTitle).setMessage(R.string.gpsNotifyMsg).setNegativeButton(R.string.cancel,new DialogInterface.OnClickListener(){	        @Override public void onClick(        DialogInterface dialog,        int which){	          finish();	        }	      }	).setPositiveButton(R.string.setting,new DialogInterface.OnClickListener(){	        @Override public void onClick(        DialogInterface dialog,        int which){	          Intent intent=new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);	          startActivityForResult(intent,REQUEST_CODE_OPEN_GPS);	        }	      }	).setCancelable(false).show();	    }	 else {	      setScanRule();	      startScan();	    }	  break;	}	}
@Override public void onClick(DialogInterface dialog,int which){	  finish();	}
@Override public void onClick(DialogInterface dialog,int which){	  Intent intent=new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS);	  startActivityForResult(intent,REQUEST_CODE_OPEN_GPS);	}
private boolean checkGPSIsOpen(){	  LocationManager locationManager=(LocationManager)this.getSystemService(Context.LOCATION_SERVICE);	  if (locationManager == null)   return false;	  return locationManager.isProviderEnabled(android.location.LocationManager.GPS_PROVIDER);	}
@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){	  super.onActivityResult(requestCode,resultCode,data);	  if (requestCode == REQUEST_CODE_OPEN_GPS) {	    if (checkGPSIsOpen()) {	      setScanRule();	      startScan();	    }	  }	}
public DeviceAdapter(Context context){	  this.context=context;	  bleDeviceList=new ArrayList<>();	}
public void addDevice(BleDevice bleDevice){	  removeDevice(bleDevice);	  bleDeviceList.add(bleDevice);	}
public void removeDevice(BleDevice bleDevice){	  for (int i=0; i < bleDeviceList.size(); i++) {	    BleDevice device=bleDeviceList.get(i);	    if (bleDevice.getKey().equals(device.getKey())) {	      bleDeviceList.remove(i);	    }	  }	}
public void clearConnectedDevice(){	  for (int i=0; i < bleDeviceList.size(); i++) {	    BleDevice device=bleDeviceList.get(i);	    if (BleManager.getInstance().isConnected(device)) {	      bleDeviceList.remove(i);	    }	  }	}
public void clearScanDevice(){	  for (int i=0; i < bleDeviceList.size(); i++) {	    BleDevice device=bleDeviceList.get(i);	    if (!BleManager.getInstance().isConnected(device)) {	      bleDeviceList.remove(i);	    }	  }	}
public void clear(){	  clearConnectedDevice();	  clearScanDevice();	}
@Override public int getCount(){	  return bleDeviceList.size();	}
@Override public BleDevice getItem(int position){	  if (position > bleDeviceList.size())   return null;	  return bleDeviceList.get(position);	}
@Override public long getItemId(int position){	  return 0;	}
@Override public View getView(int position,View convertView,ViewGroup parent){	  ViewHolder holder;	  if (convertView != null) {	    holder=(ViewHolder)convertView.getTag();	  }	 else {	    convertView=View.inflate(context,R.layout.adapter_device,null);	    holder=new ViewHolder();	    convertView.setTag(holder);	    holder.img_blue=(ImageView)convertView.findViewById(R.id.img_blue);	    holder.txt_name=(TextView)convertView.findViewById(R.id.txt_name);	    holder.txt_mac=(TextView)convertView.findViewById(R.id.txt_mac);	    holder.txt_rssi=(TextView)convertView.findViewById(R.id.txt_rssi);	    holder.layout_idle=(LinearLayout)convertView.findViewById(R.id.layout_idle);	    holder.layout_connected=(LinearLayout)convertView.findViewById(R.id.layout_connected);	    holder.btn_disconnect=(Button)convertView.findViewById(R.id.btn_disconnect);	    holder.btn_connect=(Button)convertView.findViewById(R.id.btn_connect);	    holder.btn_detail=(Button)convertView.findViewById(R.id.btn_detail);	  }	  final BleDevice bleDevice=getItem(position);	  if (bleDevice != null) {	    boolean isConnected=BleManager.getInstance().isConnected(bleDevice);	    String name=bleDevice.getName();	    String mac=bleDevice.getMac();	    int rssi=bleDevice.getRssi();	    holder.txt_name.setText(name);	    holder.txt_mac.setText(mac);	    holder.txt_rssi.setText(String.valueOf(rssi));	    if (isConnected) {	      holder.img_blue.setImageResource(R.mipmap.ic_blue_connected);	      holder.txt_name.setTextColor(0xFF1DE9B6);	      holder.txt_mac.setTextColor(0xFF1DE9B6);	      holder.layout_idle.setVisibility(View.GONE);	      holder.layout_connected.setVisibility(View.VISIBLE);	    }	 else {	      holder.img_blue.setImageResource(R.mipmap.ic_blue_remote);	      holder.txt_name.setTextColor(0xFF000000);	      holder.txt_mac.setTextColor(0xFF000000);	      holder.layout_idle.setVisibility(View.VISIBLE);	      holder.layout_connected.setVisibility(View.GONE);	    }	  }	  holder.btn_connect.setOnClickListener(new View.OnClickListener(){	    @Override public void onClick(    View view){	      if (mListener != null) {	        mListener.onConnect(bleDevice);	      }	    }	  }	);	  holder.btn_disconnect.setOnClickListener(new View.OnClickListener(){	    @Override public void onClick(    View view){	      if (mListener != null) {	        mListener.onDisConnect(bleDevice);	      }	    }	  }	);	  holder.btn_detail.setOnClickListener(new View.OnClickListener(){	    @Override public void onClick(    View view){	      if (mListener != null) {	        mListener.onDetail(bleDevice);	      }	    }	  }	);	  return convertView;	}
@Override public void onClick(View view){	  if (mListener != null) {	    mListener.onConnect(bleDevice);	  }	}
@Override public void onClick(View view){	  if (mListener != null) {	    mListener.onDisConnect(bleDevice);	  }	}
@Override public void onClick(View view){	  if (mListener != null) {	    mListener.onDetail(bleDevice);	  }	}
public void setOnDeviceClickListener(OnDeviceClickListener listener){	  this.mListener=listener;	}
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){	  View v=inflater.inflate(R.layout.fragment_service_list,null);	  initView(v);	  showData();	  return v;	}
private void initView(View v){	  txt_name=(TextView)v.findViewById(R.id.txt_name);	  txt_mac=(TextView)v.findViewById(R.id.txt_mac);	  mResultAdapter=new ResultAdapter(getActivity());	  ListView listView_device=(ListView)v.findViewById(R.id.list_service);	  listView_device.setAdapter(mResultAdapter);	  listView_device.setOnItemClickListener(new AdapterView.OnItemClickListener(){	    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){	      BluetoothGattService service=mResultAdapter.getItem(position);	      ((OperationActivity)getActivity()).setBluetoothGattService(service);	      ((OperationActivity)getActivity()).changePage(1);	    }	  }	);	}
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){	  BluetoothGattService service=mResultAdapter.getItem(position);	  ((OperationActivity)getActivity()).setBluetoothGattService(service);	  ((OperationActivity)getActivity()).changePage(1);	}
private void showData(){	  BleDevice bleDevice=((OperationActivity)getActivity()).getBleDevice();	  String name=bleDevice.getName();	  String mac=bleDevice.getMac();	  BluetoothGatt gatt=BleManager.getInstance().getBluetoothGatt(bleDevice);	  txt_name.setText(String.valueOf(getActivity().getString(R.string.name) + name));	  txt_mac.setText(String.valueOf(getActivity().getString(R.string.mac) + mac));	  mResultAdapter.clear();	  for (  BluetoothGattService service : gatt.getServices()) {	    mResultAdapter.addResult(service);	  }	  mResultAdapter.notifyDataSetChanged();	}
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){	  View v=inflater.inflate(R.layout.fragment_characteric_operation,null);	  initView(v);	  return v;	}
private void initView(View v){	  layout_container=(LinearLayout)v.findViewById(R.id.layout_container);	}
public void showData(){	  final BleDevice bleDevice=((OperationActivity)getActivity()).getBleDevice();	  final BluetoothGattCharacteristic characteristic=((OperationActivity)getActivity()).getCharacteristic();	  final int charaProp=((OperationActivity)getActivity()).getCharaProp();	  String child=characteristic.getUuid().toString() + String.valueOf(charaProp);	  for (int i=0; i < layout_container.getChildCount(); i++) {	    layout_container.getChildAt(i).setVisibility(View.GONE);	  }	  if (childList.contains(child)) {	    layout_container.findViewWithTag(bleDevice.getKey() + characteristic.getUuid().toString() + charaProp).setVisibility(View.VISIBLE);	  }	 else {	    childList.add(child);	    View view=LayoutInflater.from(getActivity()).inflate(R.layout.layout_characteric_operation,null);	    view.setTag(bleDevice.getKey() + characteristic.getUuid().toString() + charaProp);	    LinearLayout layout_add=(LinearLayout)view.findViewById(R.id.layout_add);	    final TextView txt_title=(TextView)view.findViewById(R.id.txt_title);	    txt_title.setText(String.valueOf(characteristic.getUuid().toString() + getActivity().getString(R.string.data_changed)));	    final TextView txt=(TextView)view.findViewById(R.id.txt);	    txt.setMovementMethod(ScrollingMovementMethod.getInstance());	switch (charaProp) {	case PROPERTY_READ:	{	        View view_add=LayoutInflater.from(getActivity()).inflate(R.layout.layout_characteric_operation_button,null);	        Button btn=(Button)view_add.findViewById(R.id.btn);	        btn.setText(getActivity().getString(R.string.read));	        btn.setOnClickListener(new View.OnClickListener(){	          @Override public void onClick(          View view){	            BleManager.getInstance().read(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),new BleReadCallback(){	              @Override public void onReadSuccess(              final byte[] data){	                runOnUiThread(new Runnable(){	                  @Override public void run(){	                    addText(txt,HexUtil.formatHexString(data,true));	                  }	                }	);	              }	              @Override public void onReadFailure(              final BleException exception){	                runOnUiThread(new Runnable(){	                  @Override public void run(){	                    addText(txt,exception.toString());	                  }	                }	);	              }	            }	);	          }	        }	);	        layout_add.addView(view_add);	      }	    break;	case PROPERTY_WRITE:	{	    View view_add=LayoutInflater.from(getActivity()).inflate(R.layout.layout_characteric_operation_et,null);	    final EditText et=(EditText)view_add.findViewById(R.id.et);	    Button btn=(Button)view_add.findViewById(R.id.btn);	    btn.setText(getActivity().getString(R.string.write));	    btn.setOnClickListener(new View.OnClickListener(){	      @Override public void onClick(      View view){	        String hex=et.getText().toString();	        if (TextUtils.isEmpty(hex)) {	          return;	        }	        BleManager.getInstance().write(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),HexUtil.hexStringToBytes(hex),new BleWriteCallback(){	          @Override public void onWriteSuccess(          final int current,          final int total,          final byte[] justWrite){	            runOnUiThread(new Runnable(){	              @Override public void run(){	                addText(txt,"write success, current: " + current + " total: "+ total+ " justWrite: "+ HexUtil.formatHexString(justWrite,true));	              }	            }	);	          }	          @Override public void onWriteFailure(          final BleException exception){	            runOnUiThread(new Runnable(){	              @Override public void run(){	                addText(txt,exception.toString());	              }	            }	);	          }	        }	);	      }	    }	);	    layout_add.addView(view_add);	  }	break;	case PROPERTY_WRITE_NO_RESPONSE:	{	View view_add=LayoutInflater.from(getActivity()).inflate(R.layout.layout_characteric_operation_et,null);	final EditText et=(EditText)view_add.findViewById(R.id.et);	Button btn=(Button)view_add.findViewById(R.id.btn);	btn.setText(getActivity().getString(R.string.write));	btn.setOnClickListener(new View.OnClickListener(){	  @Override public void onClick(  View view){	    String hex=et.getText().toString();	    if (TextUtils.isEmpty(hex)) {	      return;	    }	    BleManager.getInstance().write(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),HexUtil.hexStringToBytes(hex),new BleWriteCallback(){	      @Override public void onWriteSuccess(      final int current,      final int total,      final byte[] justWrite){	        runOnUiThread(new Runnable(){	          @Override public void run(){	            addText(txt,"write success, current: " + current + " total: "+ total+ " justWrite: "+ HexUtil.formatHexString(justWrite,true));	          }	        }	);	      }	      @Override public void onWriteFailure(      final BleException exception){	        runOnUiThread(new Runnable(){	          @Override public void run(){	            addText(txt,exception.toString());	          }	        }	);	      }	    }	);	  }	}	);	layout_add.addView(view_add);	}	break;	case PROPERTY_NOTIFY:	{	View view_add=LayoutInflater.from(getActivity()).inflate(R.layout.layout_characteric_operation_button,null);	final Button btn=(Button)view_add.findViewById(R.id.btn);	btn.setText(getActivity().getString(R.string.open_notification));	btn.setOnClickListener(new View.OnClickListener(){	@Override public void onClick(View view){	if (btn.getText().toString().equals(getActivity().getString(R.string.open_notification))) {	  btn.setText(getActivity().getString(R.string.close_notification));	  BleManager.getInstance().notify(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),new BleNotifyCallback(){	    @Override public void onNotifySuccess(){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,"notify success");	        }	      }	);	    }	    @Override public void onNotifyFailure(    final BleException exception){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,exception.toString());	        }	      }	);	    }	    @Override public void onCharacteristicChanged(    byte[] data){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,HexUtil.formatHexString(characteristic.getValue(),true));	        }	      }	);	    }	  }	);	}	 else {	  btn.setText(getActivity().getString(R.string.open_notification));	  BleManager.getInstance().stopNotify(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString());	}	}	}	);	layout_add.addView(view_add);	}	break;	case PROPERTY_INDICATE:	{	View view_add=LayoutInflater.from(getActivity()).inflate(R.layout.layout_characteric_operation_button,null);	final Button btn=(Button)view_add.findViewById(R.id.btn);	btn.setText(getActivity().getString(R.string.open_notification));	btn.setOnClickListener(new View.OnClickListener(){	@Override public void onClick(View view){	if (btn.getText().toString().equals(getActivity().getString(R.string.open_notification))) {	btn.setText(getActivity().getString(R.string.close_notification));	BleManager.getInstance().indicate(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),new BleIndicateCallback(){	@Override public void onIndicateSuccess(){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,"indicate success");	    }	  }	);	}	@Override public void onIndicateFailure(final BleException exception){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,exception.toString());	    }	  }	);	}	@Override public void onCharacteristicChanged(byte[] data){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,HexUtil.formatHexString(characteristic.getValue(),true));	    }	  }	);	}	}	);	}	 else {	btn.setText(getActivity().getString(R.string.open_notification));	BleManager.getInstance().stopIndicate(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString());	}	}	}	);	layout_add.addView(view_add);	}	break;	}	layout_container.addView(view);	}	}
@Override public void onClick(View view){	  BleManager.getInstance().read(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),new BleReadCallback(){	    @Override public void onReadSuccess(    final byte[] data){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,HexUtil.formatHexString(data,true));	        }	      }	);	    }	    @Override public void onReadFailure(    final BleException exception){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,exception.toString());	        }	      }	);	    }	  }	);	}
@Override public void onReadSuccess(final byte[] data){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,HexUtil.formatHexString(data,true));	    }	  }	);	}
@Override public void run(){	  addText(txt,HexUtil.formatHexString(data,true));	}
@Override public void onReadFailure(final BleException exception){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,exception.toString());	    }	  }	);	}
@Override public void run(){	  addText(txt,exception.toString());	}
@Override public void onClick(View view){	  String hex=et.getText().toString();	  if (TextUtils.isEmpty(hex)) {	    return;	  }	  BleManager.getInstance().write(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),HexUtil.hexStringToBytes(hex),new BleWriteCallback(){	    @Override public void onWriteSuccess(    final int current,    final int total,    final byte[] justWrite){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,"write success, current: " + current + " total: "+ total+ " justWrite: "+ HexUtil.formatHexString(justWrite,true));	        }	      }	);	    }	    @Override public void onWriteFailure(    final BleException exception){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,exception.toString());	        }	      }	);	    }	  }	);	}
@Override public void onWriteSuccess(final int current,final int total,final byte[] justWrite){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,"write success, current: " + current + " total: "+ total+ " justWrite: "+ HexUtil.formatHexString(justWrite,true));	    }	  }	);	}
@Override public void run(){	  addText(txt,"write success, current: " + current + " total: "+ total+ " justWrite: "+ HexUtil.formatHexString(justWrite,true));	}
@Override public void onWriteFailure(final BleException exception){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,exception.toString());	    }	  }	);	}
@Override public void run(){	  addText(txt,exception.toString());	}
@Override public void onClick(View view){	  String hex=et.getText().toString();	  if (TextUtils.isEmpty(hex)) {	    return;	  }	  BleManager.getInstance().write(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),HexUtil.hexStringToBytes(hex),new BleWriteCallback(){	    @Override public void onWriteSuccess(    final int current,    final int total,    final byte[] justWrite){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,"write success, current: " + current + " total: "+ total+ " justWrite: "+ HexUtil.formatHexString(justWrite,true));	        }	      }	);	    }	    @Override public void onWriteFailure(    final BleException exception){	      runOnUiThread(new Runnable(){	        @Override public void run(){	          addText(txt,exception.toString());	        }	      }	);	    }	  }	);	}
@Override public void onWriteSuccess(final int current,final int total,final byte[] justWrite){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,"write success, current: " + current + " total: "+ total+ " justWrite: "+ HexUtil.formatHexString(justWrite,true));	    }	  }	);	}
@Override public void run(){	  addText(txt,"write success, current: " + current + " total: "+ total+ " justWrite: "+ HexUtil.formatHexString(justWrite,true));	}
@Override public void onWriteFailure(final BleException exception){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,exception.toString());	    }	  }	);	}
@Override public void run(){	  addText(txt,exception.toString());	}
@Override public void onClick(View view){	  if (btn.getText().toString().equals(getActivity().getString(R.string.open_notification))) {	    btn.setText(getActivity().getString(R.string.close_notification));	    BleManager.getInstance().notify(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),new BleNotifyCallback(){	      @Override public void onNotifySuccess(){	        runOnUiThread(new Runnable(){	          @Override public void run(){	            addText(txt,"notify success");	          }	        }	);	      }	      @Override public void onNotifyFailure(      final BleException exception){	        runOnUiThread(new Runnable(){	          @Override public void run(){	            addText(txt,exception.toString());	          }	        }	);	      }	      @Override public void onCharacteristicChanged(      byte[] data){	        runOnUiThread(new Runnable(){	          @Override public void run(){	            addText(txt,HexUtil.formatHexString(characteristic.getValue(),true));	          }	        }	);	      }	    }	);	  }	 else {	    btn.setText(getActivity().getString(R.string.open_notification));	    BleManager.getInstance().stopNotify(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString());	  }	}
@Override public void onNotifySuccess(){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,"notify success");	    }	  }	);	}
@Override public void run(){	  addText(txt,"notify success");	}
@Override public void onNotifyFailure(final BleException exception){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,exception.toString());	    }	  }	);	}
@Override public void run(){	  addText(txt,exception.toString());	}
@Override public void onCharacteristicChanged(byte[] data){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,HexUtil.formatHexString(characteristic.getValue(),true));	    }	  }	);	}
@Override public void run(){	  addText(txt,HexUtil.formatHexString(characteristic.getValue(),true));	}
@Override public void onClick(View view){	  if (btn.getText().toString().equals(getActivity().getString(R.string.open_notification))) {	    btn.setText(getActivity().getString(R.string.close_notification));	    BleManager.getInstance().indicate(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString(),new BleIndicateCallback(){	      @Override public void onIndicateSuccess(){	        runOnUiThread(new Runnable(){	          @Override public void run(){	            addText(txt,"indicate success");	          }	        }	);	      }	      @Override public void onIndicateFailure(      final BleException exception){	        runOnUiThread(new Runnable(){	          @Override public void run(){	            addText(txt,exception.toString());	          }	        }	);	      }	      @Override public void onCharacteristicChanged(      byte[] data){	        runOnUiThread(new Runnable(){	          @Override public void run(){	            addText(txt,HexUtil.formatHexString(characteristic.getValue(),true));	          }	        }	);	      }	    }	);	  }	 else {	    btn.setText(getActivity().getString(R.string.open_notification));	    BleManager.getInstance().stopIndicate(bleDevice,characteristic.getService().getUuid().toString(),characteristic.getUuid().toString());	  }	}
@Override public void onIndicateSuccess(){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,"indicate success");	    }	  }	);	}
@Override public void run(){	  addText(txt,"indicate success");	}
@Override public void onIndicateFailure(final BleException exception){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,exception.toString());	    }	  }	);	}
@Override public void run(){	  addText(txt,exception.toString());	}
@Override public void onCharacteristicChanged(byte[] data){	  runOnUiThread(new Runnable(){	    @Override public void run(){	      addText(txt,HexUtil.formatHexString(characteristic.getValue(),true));	    }	  }	);	}
@Override public void run(){	  addText(txt,HexUtil.formatHexString(characteristic.getValue(),true));	}
private void runOnUiThread(Runnable runnable){	  if (isAdded() && getActivity() != null)   getActivity().runOnUiThread(runnable);	}
private void addText(TextView textView,String content){	  textView.append(content);	  textView.append("\n");	  int offset=textView.getLineCount() * textView.getLineHeight();	  if (offset > textView.getHeight()) {	    textView.scrollTo(0,offset - textView.getHeight());	  }	}
@Override protected void onCreate(Bundle savedInstanceState){	  super.onCreate(savedInstanceState);	  setContentView(R.layout.activity_operation);	  initData();	  initView();	  initPage();	  ObserverManager.getInstance().addObserver(this);	}
@Override protected void onDestroy(){	  super.onDestroy();	  BleManager.getInstance().clearCharacterCallback(bleDevice);	  ObserverManager.getInstance().deleteObserver(this);	}
@Override public void disConnected(BleDevice device){	  if (device != null && bleDevice != null && device.getKey().equals(bleDevice.getKey())) {	    finish();	  }	}
@Override public boolean onKeyDown(int keyCode,KeyEvent event){	  if (keyCode == KeyEvent.KEYCODE_BACK) {	    if (currentPage != 0) {	      currentPage--;	      changePage(currentPage);	      return true;	    }	 else {	      finish();	      return true;	    }	  }	  return super.onKeyDown(keyCode,event);	}
private void initView(){	  toolbar=(Toolbar)findViewById(R.id.toolbar);	  toolbar.setTitle(titles[0]);	  setSupportActionBar(toolbar);	  getSupportActionBar().setDisplayHomeAsUpEnabled(true);	  toolbar.setNavigationOnClickListener(new View.OnClickListener(){	    @Override public void onClick(    View view){	      if (currentPage != 0) {	        currentPage--;	        changePage(currentPage);	      }	 else {	        finish();	      }	    }	  }	);	}
@Override public void onClick(View view){	  if (currentPage != 0) {	    currentPage--;	    changePage(currentPage);	  }	 else {	    finish();	  }	}
private void initData(){	  bleDevice=getIntent().getParcelableExtra(KEY_DATA);	  if (bleDevice == null)   finish();	  titles=new String[]{getString(R.string.service_list),getString(R.string.characteristic_list),getString(R.string.console)};	}
private void initPage(){	  prepareFragment();	  changePage(0);	}
public void changePage(int page){	  currentPage=page;	  toolbar.setTitle(titles[page]);	  updateFragment(page);	  if (currentPage == 1) {	    ((CharacteristicListFragment)fragments.get(1)).showData();	  }	 else   if (currentPage == 2) {	    ((CharacteristicOperationFragment)fragments.get(2)).showData();	  }	}
private void prepareFragment(){	  fragments.add(new ServiceListFragment());	  fragments.add(new CharacteristicListFragment());	  fragments.add(new CharacteristicOperationFragment());	  for (  Fragment fragment : fragments) {	    getSupportFragmentManager().beginTransaction().add(R.id.fragment,fragment).hide(fragment).commit();	  }	}
private void updateFragment(int position){	  if (position > fragments.size() - 1) {	    return;	  }	  for (int i=0; i < fragments.size(); i++) {	    FragmentTransaction transaction=getSupportFragmentManager().beginTransaction();	    Fragment fragment=fragments.get(i);	    if (i == position) {	      transaction.show(fragment);	    }	 else {	      transaction.hide(fragment);	    }	    transaction.commit();	  }	}
public BleDevice getBleDevice(){	  return bleDevice;	}
public BluetoothGattService getBluetoothGattService(){	  return bluetoothGattService;	}
public void setBluetoothGattService(BluetoothGattService bluetoothGattService){	  this.bluetoothGattService=bluetoothGattService;	}
public BluetoothGattCharacteristic getCharacteristic(){	  return characteristic;	}
public void setCharacteristic(BluetoothGattCharacteristic characteristic){	  this.characteristic=characteristic;	}
public int getCharaProp(){	  return charaProp;	}
public void setCharaProp(int charaProp){	  this.charaProp=charaProp;	}
@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){	  View v=inflater.inflate(R.layout.fragment_characteric_list,null);	  initView(v);	  return v;	}
private void initView(View v){	  mResultAdapter=new ResultAdapter(getActivity());	  ListView listView_device=(ListView)v.findViewById(R.id.list_service);	  listView_device.setAdapter(mResultAdapter);	  listView_device.setOnItemClickListener(new AdapterView.OnItemClickListener(){	    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){	      final BluetoothGattCharacteristic characteristic=mResultAdapter.getItem(position);	      final List<Integer> propList=new ArrayList<>();	      List<String> propNameList=new ArrayList<>();	      int charaProp=characteristic.getProperties();	      if ((charaProp & BluetoothGattCharacteristic.PROPERTY_READ) > 0) {	        propList.add(CharacteristicOperationFragment.PROPERTY_READ);	        propNameList.add("Read");	      }	      if ((charaProp & BluetoothGattCharacteristic.PROPERTY_WRITE) > 0) {	        propList.add(CharacteristicOperationFragment.PROPERTY_WRITE);	        propNameList.add("Write");	      }	      if ((charaProp & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) > 0) {	        propList.add(CharacteristicOperationFragment.PROPERTY_WRITE_NO_RESPONSE);	        propNameList.add("Write No Response");	      }	      if ((charaProp & BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	        propList.add(CharacteristicOperationFragment.PROPERTY_NOTIFY);	        propNameList.add("Notify");	      }	      if ((charaProp & BluetoothGattCharacteristic.PROPERTY_INDICATE) > 0) {	        propList.add(CharacteristicOperationFragment.PROPERTY_INDICATE);	        propNameList.add("Indicate");	      }	      if (propList.size() > 1) {	        new AlertDialog.Builder(getActivity()).setTitle(getActivity().getString(R.string.select_operation_type)).setItems(propNameList.toArray(new String[propNameList.size()]),new DialogInterface.OnClickListener(){	          @Override public void onClick(          DialogInterface dialog,          int which){	            ((OperationActivity)getActivity()).setCharacteristic(characteristic);	            ((OperationActivity)getActivity()).setCharaProp(propList.get(which));	            ((OperationActivity)getActivity()).changePage(2);	          }	        }	).show();	      }	 else       if (propList.size() > 0) {	        ((OperationActivity)getActivity()).setCharacteristic(characteristic);	        ((OperationActivity)getActivity()).setCharaProp(propList.get(0));	        ((OperationActivity)getActivity()).changePage(2);	      }	    }	  }	);	}
@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){	  final BluetoothGattCharacteristic characteristic=mResultAdapter.getItem(position);	  final List<Integer> propList=new ArrayList<>();	  List<String> propNameList=new ArrayList<>();	  int charaProp=characteristic.getProperties();	  if ((charaProp & BluetoothGattCharacteristic.PROPERTY_READ) > 0) {	    propList.add(CharacteristicOperationFragment.PROPERTY_READ);	    propNameList.add("Read");	  }	  if ((charaProp & BluetoothGattCharacteristic.PROPERTY_WRITE) > 0) {	    propList.add(CharacteristicOperationFragment.PROPERTY_WRITE);	    propNameList.add("Write");	  }	  if ((charaProp & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) > 0) {	    propList.add(CharacteristicOperationFragment.PROPERTY_WRITE_NO_RESPONSE);	    propNameList.add("Write No Response");	  }	  if ((charaProp & BluetoothGattCharacteristic.PROPERTY_NOTIFY) > 0) {	    propList.add(CharacteristicOperationFragment.PROPERTY_NOTIFY);	    propNameList.add("Notify");	  }	  if ((charaProp & BluetoothGattCharacteristic.PROPERTY_INDICATE) > 0) {	    propList.add(CharacteristicOperationFragment.PROPERTY_INDICATE);	    propNameList.add("Indicate");	  }	  if (propList.size() > 1) {	    new AlertDialog.Builder(getActivity()).setTitle(getActivity().getString(R.string.select_operation_type)).setItems(propNameList.toArray(new String[propNameList.size()]),new DialogInterface.OnClickListener(){	      @Override public void onClick(      DialogInterface dialog,      int which){	        ((OperationActivity)getActivity()).setCharacteristic(characteristic);	        ((OperationActivity)getActivity()).setCharaProp(propList.get(which));	        ((OperationActivity)getActivity()).changePage(2);	      }	    }	).show();	  }	 else   if (propList.size() > 0) {	    ((OperationActivity)getActivity()).setCharacteristic(characteristic);	    ((OperationActivity)getActivity()).setCharaProp(propList.get(0));	    ((OperationActivity)getActivity()).changePage(2);	  }	}
@Override public void onClick(DialogInterface dialog,int which){	  ((OperationActivity)getActivity()).setCharacteristic(characteristic);	  ((OperationActivity)getActivity()).setCharaProp(propList.get(which));	  ((OperationActivity)getActivity()).changePage(2);	}
public void showData(){	  BluetoothGattService service=((OperationActivity)getActivity()).getBluetoothGattService();	  mResultAdapter.clear();	  for (  BluetoothGattCharacteristic characteristic : service.getCharacteristics()) {	    mResultAdapter.addResult(characteristic);	  }	  mResultAdapter.notifyDataSetChanged();	}
void disConnected(BleDevice bleDevice);
public static ObserverManager getInstance(){	  return ObserverManagerHolder.sObserverManager;	}
@Override public void addObserver(Observer obj){	  observers.add(obj);	}
@Override public void deleteObserver(Observer obj){	  int i=observers.indexOf(obj);	  if (i >= 0) {	    observers.remove(obj);	  }	}
@Override public void notifyObserver(BleDevice bleDevice){	  for (int i=0; i < observers.size(); i++) {	    Observer o=observers.get(i);	    o.disConnected(bleDevice);	  }	}
void addObserver(Observer obj);
void deleteObserver(Observer obj);
void notifyObserver(BleDevice bleDevice);
private PublicSuffixPatterns(){	}
static ImmutableMap<String,PublicSuffixType> parseTrie(CharSequence encoded){	  ImmutableMap.Builder<String,PublicSuffixType> builder=ImmutableMap.builder();	  int encodedLen=encoded.length();	  int idx=0;	  while (idx < encodedLen) {	    idx+=doParseTrieToBuilder(Lists.<CharSequence>newLinkedList(),encoded,idx,builder);	  }	  return builder.build();	}
private static int doParseTrieToBuilder(List<CharSequence> stack,CharSequence encoded,int start,ImmutableMap.Builder<String,PublicSuffixType> builder){	  int encodedLen=encoded.length();	  int idx=start;	  char c='\0';	  for (; idx < encodedLen; idx++) {	    c=encoded.charAt(idx);	    if (c == '&' || c == '?' || c == '!' || c == ':' || c == ',') {	      break;	    }	  }	  stack.add(0,reverse(encoded.subSequence(start,idx)));	  if (c == '!' || c == '?' || c == ':' || c == ',') {	    String domain=PREFIX_JOINER.join(stack);	    if (domain.length() > 0) {	      builder.put(domain,PublicSuffixType.fromCode(c));	    }	  }	  idx++;	  if (c != '?' && c != ',') {	    while (idx < encodedLen) {	      idx+=doParseTrieToBuilder(stack,encoded,idx,builder);	      if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {	        idx++;	        break;	      }	    }	  }	  stack.remove(0);	  return idx - start;	}
private static CharSequence reverse(CharSequence s){	  return new StringBuilder(s).reverse();	}
private PublicSuffixPatterns(){	}
static ImmutableMap<String,PublicSuffixType> parseTrie(CharSequence encoded){	  ImmutableMap.Builder<String,PublicSuffixType> builder=ImmutableMap.builder();	  int encodedLen=encoded.length();	  int idx=0;	  while (idx < encodedLen) {	    idx+=doParseTrieToBuilder(Lists.<CharSequence>newLinkedList(),encoded,idx,builder);	  }	  return builder.build();	}
private static int doParseTrieToBuilder(List<CharSequence> stack,CharSequence encoded,int start,ImmutableMap.Builder<String,PublicSuffixType> builder){	  int encodedLen=encoded.length();	  int idx=start;	  char c='\0';	  for (; idx < encodedLen; idx++) {	    c=encoded.charAt(idx);	    if (c == '&' || c == '?' || c == '!' || c == ':' || c == ',') {	      break;	    }	  }	  stack.add(0,reverse(encoded.subSequence(start,idx)));	  if (c == '!' || c == '?' || c == ':' || c == ',') {	    String domain=PREFIX_JOINER.join(stack);	    if (domain.length() > 0) {	      builder.put(domain,PublicSuffixType.fromCode(c));	    }	  }	  idx++;	  if (c != '?' && c != ',') {	    while (idx < encodedLen) {	      idx+=doParseTrieToBuilder(stack,encoded,idx,builder);	      if (encoded.charAt(idx) == '?' || encoded.charAt(idx) == ',') {	        idx++;	        break;	      }	    }	  }	  stack.remove(0);	  return idx - start;	}
private static CharSequence reverse(CharSequence s){	  return new StringBuilder(s).reverse();	}
@Beta public static BigInteger ceilingPowerOfTwo(BigInteger x){	  return BigInteger.ZERO.setBit(log2(x,RoundingMode.CEILING));	}
@Beta public static BigInteger floorPowerOfTwo(BigInteger x){	  return BigInteger.ZERO.setBit(log2(x,RoundingMode.FLOOR));	}
public static boolean isPowerOfTwo(BigInteger x){	  checkNotNull(x);	  return x.signum() > 0 && x.getLowestSetBit() == x.bitLength() - 1;	}
@SuppressWarnings("fallthrough") public static int log2(BigInteger x,RoundingMode mode){	  checkPositive("x",checkNotNull(x));	  int logFloor=x.bitLength() - 1;	switch (mode) {	case UNNECESSARY:	    checkRoundingUnnecessary(isPowerOfTwo(x));	case DOWN:	case FLOOR:	  return logFloor;	case UP:	case CEILING:	return isPowerOfTwo(x) ? logFloor : logFloor + 1;	case HALF_DOWN:	case HALF_UP:	case HALF_EVEN:	if (logFloor < SQRT2_PRECOMPUTE_THRESHOLD) {	BigInteger halfPower=SQRT2_PRECOMPUTED_BITS.shiftRight(SQRT2_PRECOMPUTE_THRESHOLD - logFloor);	if (x.compareTo(halfPower) <= 0) {	  return logFloor;	}	 else {	  return logFloor + 1;	}	}	BigInteger x2=x.pow(2);	int logX2Floor=x2.bitLength() - 1;	return (logX2Floor < 2 * logFloor + 1) ? logFloor : logFloor + 1;	default :	throw new AssertionError();	}	}
@GwtIncompatible @SuppressWarnings("fallthrough") public static int log10(BigInteger x,RoundingMode mode){	  checkPositive("x",x);	  if (fitsInLong(x)) {	    return LongMath.log10(x.longValue(),mode);	  }	  int approxLog10=(int)(log2(x,FLOOR) * LN_2 / LN_10);	  BigInteger approxPow=BigInteger.TEN.pow(approxLog10);	  int approxCmp=approxPow.compareTo(x);	  if (approxCmp > 0) {	    do {	      approxLog10--;	      approxPow=approxPow.divide(BigInteger.TEN);	      approxCmp=approxPow.compareTo(x);	    }	 while (approxCmp > 0);	  }	 else {	    BigInteger nextPow=BigInteger.TEN.multiply(approxPow);	    int nextCmp=nextPow.compareTo(x);	    while (nextCmp <= 0) {	      approxLog10++;	      approxPow=nextPow;	      approxCmp=nextCmp;	      nextPow=BigInteger.TEN.multiply(approxPow);	      nextCmp=nextPow.compareTo(x);	    }	  }	  int floorLog=approxLog10;	  BigInteger floorPow=approxPow;	  int floorCmp=approxCmp;	switch (mode) {	case UNNECESSARY:	    checkRoundingUnnecessary(floorCmp == 0);	case FLOOR:	case DOWN:	  return floorLog;	case CEILING:	case UP:	return floorPow.equals(x) ? floorLog : floorLog + 1;	case HALF_DOWN:	case HALF_UP:	case HALF_EVEN:	BigInteger x2=x.pow(2);	BigInteger halfPowerSquared=floorPow.pow(2).multiply(BigInteger.TEN);	return (x2.compareTo(halfPowerSquared) <= 0) ? floorLog : floorLog + 1;	default :	throw new AssertionError();	}	}
@GwtIncompatible @SuppressWarnings("fallthrough") public static BigInteger sqrt(BigInteger x,RoundingMode mode){	  checkNonNegative("x",x);	  if (fitsInLong(x)) {	    return BigInteger.valueOf(LongMath.sqrt(x.longValue(),mode));	  }	  BigInteger sqrtFloor=sqrtFloor(x);	switch (mode) {	case UNNECESSARY:	    checkRoundingUnnecessary(sqrtFloor.pow(2).equals(x));	case FLOOR:	case DOWN:	  return sqrtFloor;	case CEILING:	case UP:	int sqrtFloorInt=sqrtFloor.intValue();	boolean sqrtFloorIsExact=(sqrtFloorInt * sqrtFloorInt == x.intValue()) && sqrtFloor.pow(2).equals(x);	return sqrtFloorIsExact ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);	case HALF_DOWN:	case HALF_UP:	case HALF_EVEN:	BigInteger halfSquare=sqrtFloor.pow(2).add(sqrtFloor);	return (halfSquare.compareTo(x) >= 0) ? sqrtFloor : sqrtFloor.add(BigInteger.ONE);	default :	throw new AssertionError();	}	}
@GwtIncompatible private static BigInteger sqrtFloor(BigInteger x){	  BigInteger sqrt0;	  int log2=log2(x,FLOOR);	  if (log2 < Double.MAX_EXPONENT) {	    sqrt0=sqrtApproxWithDoubles(x);	  }	 else {	    int shift=(log2 - DoubleUtils.SIGNIFICAND_BITS) & ~1;	    sqrt0=sqrtApproxWithDoubles(x.shiftRight(shift)).shiftLeft(shift >> 1);	  }	  BigInteger sqrt1=sqrt0.add(x.divide(sqrt0)).shiftRight(1);	  if (sqrt0.equals(sqrt1)) {	    return sqrt0;	  }	  do {	    sqrt0=sqrt1;	    sqrt1=sqrt0.add(x.divide(sqrt0)).shiftRight(1);	  }	 while (sqrt1.compareTo(sqrt0) < 0);	  return sqrt0;	}
@GwtIncompatible private static BigInteger sqrtApproxWithDoubles(BigInteger x){	  return DoubleMath.roundToBigInteger(Math.sqrt(DoubleUtils.bigToDouble(x)),HALF_EVEN);	}
@GwtIncompatible public static BigInteger divide(BigInteger p,BigInteger q,RoundingMode mode){	  BigDecimal pDec=new BigDecimal(p);	  BigDecimal qDec=new BigDecimal(q);	  return pDec.divide(qDec,0,mode).toBigIntegerExact();	}
public static BigInteger factorial(int n){	  checkNonNegative("n",n);	  if (n < LongMath.factorials.length) {	    return BigInteger.valueOf(LongMath.factorials[n]);	  }	  int approxSize=IntMath.divide(n * IntMath.log2(n,CEILING),Long.SIZE,CEILING);	  ArrayList<BigInteger> bignums=new ArrayList<>(approxSize);	  int startingNumber=LongMath.factorials.length;	  long product=LongMath.factorials[startingNumber - 1];	  int shift=Long.numberOfTrailingZeros(product);	  product>>=shift;	  int productBits=LongMath.log2(product,FLOOR) + 1;	  int bits=LongMath.log2(startingNumber,FLOOR) + 1;	  int nextPowerOfTwo=1 << (bits - 1);	  for (long num=startingNumber; num <= n; num++) {	    if ((num & nextPowerOfTwo) != 0) {	      nextPowerOfTwo<<=1;	      bits++;	    }	    int tz=Long.numberOfTrailingZeros(num);	    long normalizedNum=num >> tz;	    shift+=tz;	    int normalizedBits=bits - tz;	    if (normalizedBits + productBits >= Long.SIZE) {	      bignums.add(BigInteger.valueOf(product));	      product=1;	      productBits=0;	    }	    product*=normalizedNum;	    productBits=LongMath.log2(product,FLOOR) + 1;	  }	  if (product > 1) {	    bignums.add(BigInteger.valueOf(product));	  }	  return listProduct(bignums).shiftLeft(shift);	}
static BigInteger listProduct(List<BigInteger> nums){	  return listProduct(nums,0,nums.size());	}
static BigInteger listProduct(List<BigInteger> nums,int start,int end){	switch (end - start) {	case 0:	    return BigInteger.ONE;	case 1:	  return nums.get(start);	case 2:	return nums.get(start).multiply(nums.get(start + 1));	case 3:	return nums.get(start).multiply(nums.get(start + 1)).multiply(nums.get(start + 2));	default :	int m=(end + start) >>> 1;	return listProduct(nums,start,m).multiply(listProduct(nums,m,end));	}	}
public static BigInteger binomial(int n,int k){	  checkNonNegative("n",n);	  checkNonNegative("k",k);	  checkArgument(k <= n,"k (%s) > n (%s)",k,n);	  if (k > (n >> 1)) {	    k=n - k;	  }	  if (k < LongMath.biggestBinomials.length && n <= LongMath.biggestBinomials[k]) {	    return BigInteger.valueOf(LongMath.binomial(n,k));	  }	  BigInteger accum=BigInteger.ONE;	  long numeratorAccum=n;	  long denominatorAccum=1;	  int bits=LongMath.log2(n,RoundingMode.CEILING);	  int numeratorBits=bits;	  for (int i=1; i < k; i++) {	    int p=n - i;	    int q=i + 1;	    if (numeratorBits + bits >= Long.SIZE - 1) {	      accum=accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));	      numeratorAccum=p;	      denominatorAccum=q;	      numeratorBits=bits;	    }	 else {	      numeratorAccum*=p;	      denominatorAccum*=q;	      numeratorBits+=bits;	    }	  }	  return accum.multiply(BigInteger.valueOf(numeratorAccum)).divide(BigInteger.valueOf(denominatorAccum));	}
@GwtIncompatible static boolean fitsInLong(BigInteger x){	  return x.bitLength() <= Long.SIZE - 1;	}
private BigIntegerMath(){	}
PairedStats(Stats xStats,Stats yStats,double sumOfProductsOfDeltas){	  this.xStats=xStats;	  this.yStats=yStats;	  this.sumOfProductsOfDeltas=sumOfProductsOfDeltas;	}
public long count(){	  return xStats.count();	}
public Stats xStats(){	  return xStats;	}
public Stats yStats(){	  return yStats;	}
public double populationCovariance(){	  checkState(count() != 0);	  return sumOfProductsOfDeltas / count();	}